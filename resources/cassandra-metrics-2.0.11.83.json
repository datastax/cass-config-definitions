{
    "meta": {
        "dse_version": "4.6.0",
        "aggregates": {
            "max": "<b>Max</b> - The maximum value recorded during a time interval. A higher maximum value could have occurred without it being recorded.",
            "average": "<b>Avg</b> - The average of values recorded during a time interval.",
            "total": "<b>Total</b> - Sum of the values recorded for each node during a time interval.",
            "min": "<b>Min</b> - The minimal value recorded during a time interval. A lower minimal value could have occurred without it being recorded."
        }
    },
    "write-ops": {
        "aggregation_type": "counter",
        "api_key": "write-ops",
        "description": "The number of write requests per second on the coordinator nodes, analogous to client writes. Monitoring the number of requests over a given time period reveals system write workload and usage patterns.",
        "group": "cassandra",
        "label": "Write Requests",
        "mbean": "org.apache.cassandra.metrics:type=ClientRequest,scope=Write,name=Latency",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 0,
        "scope": "general",
        "storage_name": "getSPWriteOperations",
        "type": "jmx",
        "unit": "/sec"
    },
    "write-latency-op": {
        "aggregation_type": "average",
        "api_key": "write-latency-op",
        "description": "The <i>average</i> response times (in milliseconds) of a client write. The time period starts when a node receives a client write request, and ends when the node responds back to the client. Depending on consistency level and replication factor, this may include the network latency from writing to the replicas.",
        "from_unit": "msToMicros",
        "group": "cassandra",
        "label": "Write Request Latency",
        "mbean": "org.apache.cassandra.db:type=StorageProxy",
        "metric_type": "gauge",
        "minstep": 0.1,
        "path": ["RecentWriteLatencyMicros"],
        "priority": 0,
        "scope": "general",
        "storage_name": "getSPRecentWriteLatencyMicros",
        "to_unit": "microsToMs",
        "type": "jmx",
        "unit": "ms/op"
    },
    "write-histogram": {
        "aggregation_type": "histogram",
        "allow_alerts": true,
        "api_key": "write-histogram",
        "description": "The min, median, max, 90th, and 99th percentiles of a client writes. The time period starts when a node receives a client write request, and ends when the node responds back to the client. Depending on consistency level and replication factor, this may include the network latency from writing to the replicas.",
        "group": "cassandra",
        "histogram": true,
        "label": "Write Request Latency (percentiles)",
        "label_func": "logLabel",
        "max": "<b>Max</b> - The maximum latency during a time interval.",
        "mbean": "org.apache.cassandra.db:type=StorageProxy",
        "median": "<b>Median</b> - The median, also known as the 50th percentile, represents a value where 50 percent of values during a time interval are either at or below the median value.",
        "metric_type": "histogram",
        "min": "<b>Min</b> - The minimum latency during a time interval.",
        "p90th": "<b>90th</b> - The 90th percentile represents a value where 90 percent of values during a time interval are at or below, and 10 percent of values are above, the 90th percentile value.",
        "p99th": "<b>99th</b> - The 99th percentile represents a value where 99 percent of values during a time interval are at or below, and 1 percent of values are above, the 99th percentile value.",
        "path": ["TotalWriteLatencyHistogramMicros"],
        "plot": "Areas",
        "priority": 0,
        "scale": "logScale",
        "scope": "general",
        "storage_name": "getWriteLatencyHisto",
        "to_unit": "microsToMs",
        "from_unit": "msToMicros",
        "type": "jmx",
        "unit": "ms/op"
    },
    "write-failures": {
        "aggregation_type": "counter",
        "api_key": "write-failures",
        "description": "The number of write requests on the coordinator nodes that fail due to errors returned from replicas.",
        "group": "cassandra",
        "label": "Write Failures",
        "mbean": "org.apache.cassandra.metrics:type=ClientRequest,scope=Write,name=Failures",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 1,
        "scope": "general",
        "type": "jmx",
        "unit": "/sec"
    },
    "write-timeouts": {
        "aggregation_type": "counter",
        "api_key": "write-timeouts",
        "description": "The number of server write timeouts per second on the coordinator nodes.",
        "group": "cassandra",
        "label": "Write Timeouts",
        "mbean": "org.apache.cassandra.metrics:type=ClientRequest,scope=Write,name=Timeouts",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 1,
        "scope": "general",
        "type": "jmx",
        "unit": "/sec"
    },
    "write-unavailables": {
        "aggregation_type": "counter",
        "api_key": "write-unavailables",
        "description": "The number of write requests per second on the coordinator nodes, that fail because not enough replicas are available.",
        "group": "cassandra",
        "label": "Write Unavailable Errors",
        "mbean": "org.apache.cassandra.metrics:type=ClientRequest,scope=Write,name=Unavailables",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 1,
        "scope": "general",
        "type": "jmx",
        "unit": "/sec"
    },
    "read-ops": {
        "aggregation_type": "counter",
        "api_key": "read-ops",
        "description": "The number of read requests per second on the coordinator nodes, analogous to client reads. Monitoring the number of requests over a given time period reveals system read workload and usage patterns.",
        "group": "cassandra",
        "label": "Read Requests",
        "mbean": "org.apache.cassandra.metrics:type=ClientRequest,scope=Read,name=Latency",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 1,
        "scope": "general",
        "storage_name": "getSPReadOperations",
        "type": "jmx",
        "unit": "/sec"
    },
    "read-latency-op": {
        "aggregation_type": "average",
        "api_key": "read-latency-op",
        "description": "The <i>average</i> response times (in milliseconds) of a client read. The time period starts when a node receives a client read request, and ends when the node responds back to the client. Depending on consistency level and replication factor, this may include the network latency from requesting the data\u2019s replicas.",
        "from_unit": "msToMicros",
        "group": "cassandra",
        "label": "Read Request Latency",
        "mbean": "org.apache.cassandra.db:type=StorageProxy",
        "metric_type": "gauge",
        "minstep": 0.1,
        "path": ["RecentReadLatencyMicros"],
        "priority": 1,
        "scope": "general",
        "storage_name": "getSPRecentReadLatencyMicros",
        "to_unit": "microsToMs",
        "type": "jmx",
        "unit": "ms/op"
    },
    "read-histogram": {
        "aggregation_type": "histogram",
        "allow_alerts": true,
        "api_key": "read-histogram",
        "description": "The min, median, max, 90th, and 99th percentiles of a client reads. The time period starts when a node receives a client read request, and ends when the node responds back to the client. Depending on consistency level and replication factor, this may include the network latency from requesting the data\u2019s replicas.",
        "group": "cassandra",
        "histogram": true,
        "label": "Read Request Latency (percentiles)",
        "label_func": "logLabel",
        "max": "<b>Max</b> - The maximum latency during a time interval.",
        "mbean": "org.apache.cassandra.db:type=StorageProxy",
        "median": "<b>Median</b> - The median, also known as the 50th percentile, represents a value where 50 percent of values during a time interval are either at or below the median value.",
        "metric_type": "histogram",
        "min": "<b>Min</b> - The minimum latency during a time interval.",
        "p90th": "<b>90th</b> - The 90th percentile represents a value where 90 percent of values during a time interval are at or below, and 10 percent of values are above, the 90th percentile value.",
        "p99th": "<b>99th</b> - The 99th percentile represents a value where 99 percent of values during a time interval are at or below, and 1 percent of values are above, the 99th percentile value.",
        "path": ["TotalReadLatencyHistogramMicros"],
        "plot": "Areas",
        "priority": 1,
        "scale": "logScale",
        "scope": "general",
        "storage_name": "getReadLatencyHisto",
        "to_unit": "microsToMs",
        "from_unit": "msToMicros",
        "type": "jmx",
        "unit": "ms/op"
    },
    "read-failures": {
        "aggregation_type": "counter",
        "api_key": "read-failures",
        "description": "The number of read requests on the coordinator nodes that fail due to errors returned from replicas.",
        "group": "cassandra",
        "label": "Read Failures",
        "mbean": "org.apache.cassandra.metrics:type=ClientRequest,scope=Read,name=Failures",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 1,
        "scope": "general",
        "type": "jmx",
        "unit": "/sec"
    },
    "read-timeouts": {
        "aggregation_type": "counter",
        "api_key": "read-timeouts",
        "description": "The number of server read timeouts per second on the coordinator nodes.",
        "group": "cassandra",
        "label": "Read Timeouts",
        "mbean": "org.apache.cassandra.metrics:type=ClientRequest,scope=Read,name=Timeouts",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 1,
        "scope": "general",
        "type": "jmx",
        "unit": "/sec"
    },
    "read-unavailables": {
        "aggregation_type": "counter",
        "api_key": "read-unavailables",
        "description": "The number of read requests per second on the coordinator nodes, that fail because not enough replicas are available.",
        "group": "cassandra",
        "label": "Read Unavailable Errors",
        "mbean": "org.apache.cassandra.metrics:type=ClientRequest,scope=Read,name=Unavailables",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 1,
        "scope": "general",
        "type": "jmx",
        "unit": "/sec"
    },
    "nonheap-committed": {
        "aggregation_type": "average",
        "allow_alerts": false,
        "api_key": "nonheap-committed",
        "description": "Allocated memory, guaranteed for Java nonheap.",
        "from_unit": "gbToBytes",
        "group": "cassandra",
        "label": "Non Heap Committed",
        "mbean": "java.lang:type=Memory",
        "metric_type": "gauge",
        "path": [
            "NonHeapMemoryUsage",
            "committed"
        ],
        "priority": 10,
        "scope": "general",
        "storage_name": "getNonHeapCommitted",
        "to_unit": "bytesToGb",
        "type": "jmx",
        "render_type": "filesize"
    },
    "nonheap-max": {
        "aggregation_type": "average",
        "allow_alerts": false,
        "api_key": "nonheap-max",
        "description": "Maximum amount that the Java nonheap can grow.",
        "from_unit": "gbToBytes",
        "group": "cassandra",
        "label": "Non Heap Max",
        "mbean": "java.lang:type=Memory",
        "metric_type": "gauge",
        "path": [
            "NonHeapMemoryUsage",
            "max"
        ],
        "priority": 10,
        "scope": "general",
        "storage_name": "getNonHeapMax",
        "to_unit": "bytesToGb",
        "type": "jmx",
        "render_type": "filesize"
    },
    "nonheap-used": {
        "aggregation_type": "average",
        "allow_alerts": false,
        "api_key": "nonheap-used",
        "description": "Average amount of Java nonheap memory used.",
        "from_unit": "gbToBytes",
        "group": "cassandra",
        "label": "Non Heap Used",
        "mbean": "java.lang:type=Memory",
        "metric_type": "gauge",
        "path": [
            "NonHeapMemoryUsage",
            "used"
        ],
        "priority": 10,
        "scope": "general",
        "storage_name": "getNonHeapUsed",
        "to_unit": "bytesToGb",
        "type": "jmx",
        "render_type": "filesize"
    },
    "heap-committed": {
        "aggregation_type": "average",
        "allow_alerts": false,
        "api_key": "heap-committed",
        "description": "Allocated memory guaranteed for the Java heap.",
        "from_unit": "gbToBytes",
        "group": "cassandra",
        "label": "Heap Commited",
        "mbean": "java.lang:type=Memory",
        "metric_type": "gauge",
        "path": [
            "HeapMemoryUsage",
            "committed"
        ],
        "priority": 10,
        "scope": "general",
        "storage_name": "getHeapCommitted",
        "to_unit": "bytesToGb",
        "type": "jmx",
        "render_type": "filesize"
    },
    "heap-max": {
        "aggregation_type": "average",
        "allow_alerts": true,
        "api_key": "heap-max",
        "description": "Maximum amount that the Java heap can grow.",
        "from_unit": "gbToBytes",
        "group": "cassandra",
        "label": "Heap Max",
        "mbean": "java.lang:type=Memory",
        "metric_type": "gauge",
        "minstep": 0.001,
        "path": [
            "HeapMemoryUsage",
            "max"
        ],
        "priority": 10,
        "scope": "general",
        "storage_name": "getHeapMax",
        "to_unit": "bytesToGb",
        "type": "jmx",
        "render_type": "filesize"
    },
    "heap-used": {
        "aggregation_type": "average",
        "allow_alerts": true,
        "api_key": "heap-used",
        "description": "Average amount of Java heap memory used.",
        "from_unit": "gbToBytes",
        "group": "cassandra",
        "label": "Heap Used",
        "mbean": "java.lang:type=Memory",
        "metric_type": "gauge",
        "minstep": 0.001,
        "path": [
            "HeapMemoryUsage",
            "used"
        ],
        "priority": 10,
        "scope": "general",
        "storage_name": "getHeapUsed",
        "to_unit": "bytesToGb",
        "type": "jmx",
        "render_type": "filesize"
    },
    "cms-collection-count": {
        "aggregation_type": "counter",
        "allow_alerts": true,
        "api_key": "cms-collection-count",
        "description": "Number of concurrent mark sweep garbage collections performed per second.",
        "group": "cassandra",
        "label": "JVM CMS Collection Count",
        "mbean": "java.lang:type=GarbageCollector,name=ConcurrentMarkSweep",
        "metric_type": "derive",
        "minstep": 0.01,
        "path": ["CollectionCount"],
        "priority": 15,
        "scope": "general",
        "storage_name": "getCMSCollectionCount",
        "type": "jmx",
        "unit": "/sec"
    },
    "par-new-collection-count": {
        "aggregation_type": "counter",
        "allow_alerts": true,
        "api_key": "par-new-collection-count",
        "description": "Number of ParNew garbage collections performed per second. ParNew collections pause all work in the JVM but should finish quickly.",
        "group": "cassandra",
        "label": "JVM ParNew Collection Count",
        "mbean": "java.lang:type=GarbageCollector,name=ParNew",
        "metric_type": "derive",
        "minstep": 0.1,
        "path": ["CollectionCount"],
        "priority": 15,
        "scope": "general",
        "storage_name": "getParNewCollectionCount",
        "type": "jmx",
        "unit": "/sec"
    },
    "cms-collection-time": {
        "aggregation_type": "counter",
        "allow_alerts": true,
        "api_key": "cms-collection-time",
        "description": "Average number of milliseconds spent performing CMS garbage collections per second.",
        "group": "cassandra",
        "hardmax": 1000,
        "label": "JVM CMS Collection Time",
        "mbean": "java.lang:type=GarbageCollector,name=ConcurrentMarkSweep",
        "metric_type": "derive",
        "path": ["CollectionTime"],
        "priority": 15,
        "scope": "general",
        "selectable": true,
        "storage_name": "getCMSCollectionTime",
        "type": "jmx",
        "unit": "ms/sec"
    },
    "par-new-collection-time": {
        "aggregation_type": "counter",
        "allow_alerts": true,
        "api_key": "par-new-collection-time",
        "description": "Average number of milliseconds spent performing ParNew garbage collections per second. ParNew collections pause all work in the JVM but should finish quickly.",
        "group": "cassandra",
        "hardmax": 1000,
        "label": "JVM ParNew Collection Time",
        "mbean": "java.lang:type=GarbageCollector,name=ParNew",
        "metric_type": "derive",
        "path": ["CollectionTime"],
        "priority": 15,
        "scope": "general",
        "selectable": true,
        "storage_name": "getParNewCollectionTime",
        "type": "jmx",
        "unit": "ms/sec"
    },
    "g1-old-collection-count": {
        "aggregation_type": "counter",
        "allow_alerts": true,
        "api_key": "g1-old-collection-count",
        "description": "Number of G1 old generation garbage collections performed per second.",
        "group": "cassandra",
        "label": "JVM G1 Old Collection Count",
        "mbean": "java.lang:type=GarbageCollector,name=G1 Old Generation",
        "metric_type": "derive",
        "path": ["CollectionCount"],
        "minstep": 0.01,
        "priority": 15,
        "scope": "general",
        "selectable": true,
        "type": "jmx",
        "unit": "/sec"
    },
    "g1-old-collection-time": {
        "aggregation_type": "counter",
        "allow_alerts": true,
        "api_key": "g1-old-collection-time",
        "description": "Average number of milliseconds spent performing G1 old generation garbage collections per second.",
        "group": "cassandra",
        "hardmax": 1000,
        "label": "JVM G1 Old Collection Time",
        "mbean": "java.lang:type=GarbageCollector,name=G1 Old Generation",
        "metric_type": "derive",
        "path": ["CollectionTime"],
        "priority": 15,
        "scope": "general",
        "selectable": true,
        "type": "jmx",
        "unit": "ms/sec"
    },
    "g1-young-collection-count": {
        "aggregation_type": "counter",
        "allow_alerts": true,
        "api_key": "g1-young-collection-count",
        "description": "Number of G1 young generation garbage collections performed per second.",
        "group": "cassandra",
        "label": "JVM G1 Young Collection Count",
        "mbean": "java.lang:type=GarbageCollector,name=G1 Young Generation",
        "metric_type": "derive",
        "path": ["CollectionCount"],
        "minstep": 0.01,
        "priority": 15,
        "scope": "general",
        "selectable": true,
        "type": "jmx",
        "unit": "/sec"
    },
    "g1-young-collection-time": {
        "aggregation_type": "counter",
        "allow_alerts": true,
        "api_key": "g1-young-collection-time",
        "description": "Average number of milliseconds spent performing G1 young generation garbage collections per second.",
        "group": "cassandra",
        "hardmax": 1000,
        "label": "JVM G1 Young Collection Time",
        "mbean": "java.lang:type=GarbageCollector,name=G1 Young Generation",
        "metric_type": "derive",
        "path": ["CollectionTime"],
        "priority": 15,
        "scope": "general",
        "selectable": true,
        "type": "jmx",
        "unit": "ms/sec"
    },
    "data-load": {
        "aggregation_type": "counter",
        "api_key": "data-load",
        "description": "The live disk space used by all tables on a node.",
        "from_unit": "gbToBytes",
        "group": "cassandra",
        "label": "Data Size",
        "mbean": "org.apache.cassandra.db:type=StorageService",
        "metric_type": "gauge",
        "path": ["Load"],
        "priority": 20,
        "scope": "general",
        "storage_name": "getDataLoad",
        "to_unit": "bytesToGb",
        "type": "jmx",
        "render_type": "filesize"
    },
    "total-bytes-compacted": {
        "aggregation_type": "counter",
        "api_key": "total-bytes-compacted",
        "description": "Number of bytes compacted per second.",
        "from_unit": "gbToBytes",
        "group": "cassandra",
        "label": "Total Bytes Compacted",
        "mbean": "org.apache.cassandra.metrics:type=Compaction,name=BytesCompacted",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 20,
        "scope": "general",
        "storage_name": "getTotalBytesCompacted",
        "to_unit": "bytesToGb",
        "type": "jmx",
        "render_type": "filesize",
        "unit": "/sec"
    },
    "actual-total-compactions-completed": {
        "aggregation_type": "counter",
        "api_key": "actual-total-compactions-completed",
        "description": "Number of compaction tasks completed per second.",
        "group": "cassandra",
        "label": "Total Compactions Completed",
        "mbean": "org.apache.cassandra.metrics:type=Compaction,name=TotalCompactionsCompleted",
        "metric_type": "derive",
        "minstep": 0.01,
        "path": ["Count"],
        "priority": 20,
        "scope": "general",
        "type": "jmx",
        "unit": "/sec"
    },
    "total-compactions-completed": {
        "aggregation_type": "counter",
        "api_key": "total-compactions-completed",
        "description": "Number of sstable scans per second that could result in a compaction.",
        "group": "cassandra",
        "label": "Total Compactions",
        "mbean": "org.apache.cassandra.metrics:type=Compaction,name=CompletedTasks",
        "metric_type": "derive",
        "minstep": 0.01,
        "path": ["Value"],
        "priority": 20,
        "scope": "general",
        "storage_name": "getTotalCompactionsCompleted",
        "type": "jmx",
        "unit": "/sec"
    },
    "pending-compaction-tasks": {
        "aggregation_type": "counter",
        "api_key": "pending-compaction-tasks",
        "description": "Estimated number of compactions required to achieve the desired state. This includes the pending queue to the compaction executor and additional tasks that may be created from their completion.",
        "group": "cassandra",
        "label": "Compactions Pending",
        "mbean": "org.apache.cassandra.metrics:type=Compaction,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 20,
        "scope": "general",
        "storage_name": "getCMPendingTasks",
        "type": "jmx"
    },
    "all-pending": {
        "api_key": "all-pending",
        "description": "Aggregate of thread pools pending queues that can be used to identify where things are backing up internally. This doesn't include pending compactions because it includes an estimate outside of the task queue or the hinted hand off queue, which can be in constant state of being on.",
        "group": "cassandra",
        "label": "Task Queues",
        "metrics": [
            "pending-anti-entropy-stage",
            "pending-cache-cleanup-stage",
            "pending-commitlog-archiver",
            "pending-compaction-executor",
            "pending-flushes",
            "pending-gossip-stage",
            "pending-hinted-handoff",
            "pending-internal-response-stage",
            "pending-memory-meter",
            "pending-memtable-post-flush",
            "pending-migration-stage",
            "pending-misc-stage",
            "pending-mutation-stage",
            "pending-native-transport-requests",
            "pending-pending-range-calculator",
            "pending-read-repair-stage",
            "pending-read-stage",
            "pending-repl-on-write-tasks",
            "pending-request-response-stage",
            "pending-validation-executor"
        ],
        "plot": "StackedAreas",
        "priority": 25,
        "unit": "tasks"
    },
    "all-dropped": {
        "api_key": "all-dropped",
        "description": "Aggregate of different messages that might be thrown away.",
        "group": "cassandra",
        "label": "TP: Dropped Tasks",
        "metrics": [
            "dropped-counter-mutations",
            "dropped-mutations",
            "dropped-read-repairs",
            "dropped-reads",
            "dropped-ranged-slice-reads",
            "dropped-paged-range-reads",
            "dropped-request-responses"
        ],
        "plot": "StackedAreas",
        "priority": 28,
        "unit": "drops/sec"
    },
    "dropped-counter-mutations": {
        "aggregation_type": "counter",
        "api_key": "dropped-counter-mutations",
        "description": "Mutation was seen after the timeout (write_request_timeout_in_ms) so was thrown away. This client might have timed out before it met the required consistency level, but might have succeeded as well. Hinted handoffs and read repairs should resolve inconsistencies but a repair can ensure it.",
        "group": "cassandra",
        "label": "TP: Dropped Counter Mutations",
        "mbean": "org.apache.cassandra.metrics:type=DroppedMessage,scope=COUNTER_MUTATION,name=Dropped",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 29,
        "scope": "general",
        "type": "jmx",
        "unit": "mutations/sec"
    },
    "dropped-mutations": {
        "aggregation_type": "counter",
        "api_key": "dropped-mutations",
        "description": "Mutation was seen after the timeout (write_request_timeout_in_ms) so was thrown away. This client might have timed out before it met the required consistency level, but might have succeeded as well. Hinted handoffs and read repairs should resolve inconsistencies but a repair can ensure it.",
        "group": "cassandra",
        "label": "TP: Dropped Mutations",
        "mbean": "org.apache.cassandra.metrics:type=DroppedMessage,scope=MUTATION,name=Dropped",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 29,
        "scope": "general",
        "type": "jmx",
        "unit": "mutations/sec"
    },
    "dropped-reads": {
        "aggregation_type": "counter",
        "api_key": "dropped-reads",
        "description": "A local read request was received after the timeout (read_request_timeout_in_ms) so it was thrown away because it would have already either been completed and sent to client or sent back as a timeout error.",
        "group": "cassandra",
        "label": "TP: Dropped Reads",
        "mbean": "org.apache.cassandra.metrics:type=DroppedMessage,scope=READ,name=Dropped",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 29,
        "scope": "general",
        "type": "jmx",
        "unit": "reads/sec"
    },
    "dropped-ranged-slice-reads": {
        "aggregation_type": "counter",
        "api_key": "dropped-ranged-slice-reads",
        "description": "A local ranged read request was received after the timeout (range_request_timeout_in_ms) so it was thrown away because it would have already either been completed and sent to client or sent back as a timeout error.",
        "group": "cassandra",
        "label": "TP: Dropped Ranged Slice Reads",
        "mbean": "org.apache.cassandra.metrics:type=DroppedMessage,scope=RANGE_SLICE,name=Dropped",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 29,
        "scope": "general",
        "type": "jmx",
        "unit": "reads/sec"
    },
    "dropped-paged-range-reads": {
        "aggregation_type": "counter",
        "api_key": "dropped-paged-range-reads",
        "description": "A local paged read request was received after the timeout (request_timeout_in_ms) so it was thrown away because it would have already either been completed and sent to client or sent back as a timeout error.",
        "group": "cassandra",
        "label": "TP: Dropped Paged Range Reads",
        "mbean": "org.apache.cassandra.metrics:type=DroppedMessage,scope=PAGED_RANGE,name=Dropped",
        "metric_type": "derive",
        "min-version": "2.0.0",
        "path": ["Count"],
        "priority": 29,
        "scope": "general",
        "type": "jmx",
        "unit": "reads/sec"
    },
    "dropped-request-responses": {
        "aggregation_type": "counter",
        "api_key": "dropped-request-responses",
        "description": "A response to a request was received after the timeout (request_timeout_in_ms) so it was thrown away because it would have already either been completed and sent to client or sent back as a timeout error.",
        "group": "cassandra",
        "label": "TP: Dropped Request Responses",
        "mbean": "org.apache.cassandra.metrics:type=DroppedMessage,scope=REQUEST_RESPONSE,name=Dropped",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 29,
        "scope": "general",
        "type": "jmx",
        "unit": "responses/sec"
    },
    "dropped-read-repairs": {
        "aggregation_type": "counter",
        "api_key": "dropped-read-repairs",
        "description": "The Mutation was seen after the timeout (write_request_timeout_in_ms) so was thrown away. With the read repair timeout, the node still exists in an inconsistent state.",
        "group": "cassandra",
        "label": "TP: Dropped Read Repairs",
        "mbean": "org.apache.cassandra.metrics:type=DroppedMessage,scope=READ_REPAIR,name=Dropped",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 29,
        "scope": "general",
        "type": "jmx",
        "unit": "read-repairs/sec"
    },

    "pending-commitlog-archiver": {
        "aggregation_type": "counter",
        "api_key": "pending-commitlog-archiver",
        "description": "Commitlog Archiver Pending",
        "group": "cassandra",
        "label": "TP: Commitlog Archiver Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=commitlog_archiver,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "type": "jmx"
    },
    "active-commitlog-archiver": {
        "aggregation_type": "counter",
        "api_key": "active-commitlog-archiver",
        "description": "Commitlog Archiver Active",
        "group": "cassandra",
        "label": "TP: Commitlog Archiver Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=commitlog_archiver,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "type": "jmx"
    },
    "completed-commitlog-archiver": {
        "aggregation_type": "counter",
        "api_key": "completed-commitlog-archiver",
        "description": "Commitlog Archiver Completed",
        "group": "cassandra",
        "label": "TP: Commitlog Archiver Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=commitlog_archiver,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "type": "jmx"
    },
    "blocked-commitlog-archiver": {
        "aggregation_type": "counter",
        "api_key": "blocked-commitlog-archiver",
        "description": "Commitlog Archiver Completed",
        "group": "cassandra",
        "label": "TP: Commitlog Archiver Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=commitlog_archiver,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "type": "jmx"
    },
    "total-blocked-commitlog-archiver": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-commitlog-archiver",
        "description": "Commitlog Archiver Completed",
        "group": "cassandra",
        "label": "TP: Commitlog Archiver Total Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=commitlog_archiver,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "type": "jmx"
    },
    "pending-flushes": {
        "aggregation_type": "counter",
        "api_key": "pending-flushes",
        "description": "Number of memtables queued for the flush process. A flush sorts and writes the memtables to disk, which could block writes.",
        "group": "cassandra",
        "label": "TP: Flushes Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=FlushWriter,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getFlushesPending",
        "type": "jmx"
    },
    "pending-gossip-stage": {
        "aggregation_type": "counter",
        "api_key": "pending-gossip-stage",
        "description": "Number of gossip messages and acknowledgments queued and waiting to be sent or received.",
        "group": "cassandra",
        "label": "TP: Gossip Tasks Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=GossipStage,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getGossipStagePending",
        "type": "jmx"
    },
    "pending-hinted-handoff": {
        "aggregation_type": "counter",
        "api_key": "pending-hinted-handoff",
        "description": "Number of hints in the queue waiting to be delivered after a failed node comes up.",
        "group": "cassandra",
        "label": "TP: Hinted Handoff Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=HintedHandoff,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getHHPending",
        "type": "jmx"
    },
    "pending-internal-response-stage": {
        "aggregation_type": "counter",
        "api_key": "pending-internal-response-stage",
        "description": "Number of pending tasks from internal tasks, such as nodes joining and leaving the cluster.",
        "group": "cassandra",
        "label": "TP: Internal Responses Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=InternalResponseStage,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getInternRespStagePending",
        "type": "jmx"
    },
    "pending-anti-entropy-stage": {
        "aggregation_type": "counter",
        "api_key": "pending-anti-entropy-stage",
        "description": "Repair tasks pending, such as handling the merkle tree transfer after the validation compaction.",
        "group": "cassandra",
        "label": "TP: Manual Repair Tasks Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=AntiEntropyStage,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getAesPendingTasks",
        "type": "jmx"
    },
    "pending-cache-cleanup-stage": {
        "aggregation_type": "counter",
        "api_key": "pending-cache-cleanup-stage",
        "description": "Tasks pending to clean row caches during a cleanup compaction.",
        "group": "cassandra",
        "label": "TP: Cache Cleaning Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=CacheCleanupExecutor,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "type": "jmx"
    },
    "pending-memtable-post-flush": {
        "aggregation_type": "counter",
        "api_key": "pending-memtable-post-flush",
        "description": "Number of pending tasks related to the last step in flushing memtables to disk as SSTables. Includes removing unnecessary commitlog files and committing Solr-based secondary indexes.",
        "group": "cassandra",
        "label": "TP: Memtable Post Flushers Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemtablePostFlusher,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMemtablePostFlusherPending",
        "type": "jmx"
    },
    "pending-migration-stage": {
        "aggregation_type": "counter",
        "api_key": "pending-migration-stage",
        "description": "Number of pending tasks from system methods that modified the schema.",
        "group": "cassandra",
        "label": "TP: Migrations Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MigrationStage,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMigrationStagePending",
        "type": "jmx"
    },
    "pending-misc-stage": {
        "aggregation_type": "counter",
        "api_key": "pending-misc-stage",
        "description": "Number of pending tasks from infrequently run operations, such as taking a snapshot or processing the notification of a completed replication.",
        "group": "cassandra",
        "label": "TP: Misc. Tasks Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MiscStage,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMiscStagePending",
        "type": "jmx"
    },
    "pending-read-stage": {
        "aggregation_type": "counter",
        "api_key": "pending-read-stage",
        "description": "Number of pending read requests. Read requests read data off of disk and deserialize cached data.",
        "group": "cassandra",
        "label": "TP: Read Requests Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReadStage,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getReadStagePending",
        "type": "jmx"
    },
    "pending-read-repair-stage": {
        "aggregation_type": "counter",
        "api_key": "pending-read-repair-stage",
        "description": "Number of read repair operations in the queue waiting to run.",
        "group": "cassandra",
        "label": "TP: Read Repair Tasks Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReadRepairStage,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getReadRepairStagePending",
        "type": "jmx"
    },
    "pending-repl-on-write-tasks": {
        "aggregation_type": "counter",
        "api_key": "pending-repl-on-write-tasks",
        "description": "Number of pending counter increment tasks that will read then write on the replicas after a coordinator's local write. Depending on consistency level used on writes, tasks may back up outside of the normal write path.",
        "group": "cassandra",
        "label": "TP: Repl. on Write Tasks Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReplicateOnWriteStage,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getReplOnWriteStagePending",
        "type": "jmx"
    },
    "pending-request-response-stage": {
        "aggregation_type": "counter",
        "api_key": "pending-request-response-stage",
        "description": "Number of pending callbacks to execute after a task on a remote node completes.",
        "group": "cassandra",
        "label": "TP: Request Responses Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=RequestResponseStage,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getRequestResponseStagePending",
        "type": "jmx"
    },
    "pending-mutation-stage": {
        "aggregation_type": "counter",
        "api_key": "pending-mutation-stage",
        "description": "Number of write requests received by the cluster and waiting to be handled.",
        "group": "cassandra",
        "label": "TP: Write Requests Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=MutationStage,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMutationStagePending",
        "type": "jmx"
    },
    "pending-memory-meter": {
        "aggregation_type": "counter",
        "api_key": "pending-memory-meter",
        "description": "Pending tasks that will calculate the live ratio which is used to estimate memtable size. The live ratio is the actual memory usage of a memtable including JVM overhead as it compares it to the raw data size. There will be at most one pending task per table.",
        "group": "cassandra",
        "label": "TP: Memory Meter Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemoryMeter,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMemoryMeterPending",
        "type": "jmx"
    },
    "pending-validation-executor": {
        "aggregation_type": "counter",
        "api_key": "pending-validation-executor",
        "description": "Pending task to read data from sstables and generate a merkle tree for a repair.",
        "group": "cassandra",
        "label": "TP: Validation Executor Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=ValidationExecutor,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getValidationExecutorPending",
        "type": "jmx"
    },
    "pending-compaction-executor": {
        "aggregation_type": "counter",
        "api_key": "pending-compaction-executor",
        "description": "Pending compactions that are known. This metric could deviate from \"pending compactions,\" which includes an estimate of tasks that these pending tasks might create after completion.",
        "group": "cassandra",
        "label": "TP: Compaction Executor Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=CompactionExecutor,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getCompactionExecutorPending",
        "type": "jmx"
    },
    "pending-pending-range-calculator": {
        "aggregation_type": "counter",
        "api_key": "pending-pending-range-calculator",
        "description": "Pending tasks to calculate the ranges according to bootstrapping and leaving nodes.",
        "group": "cassandra",
        "label": "TP: Pending Range Calculator Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=PendingRangeCalculator,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getPendingRangeCalculatorPending",
        "type": "jmx"
    },
    "pending-native-transport-requests": {
        "aggregation_type": "counter",
        "api_key": "pending-native-transport-requests",
        "description": "Native Transport Requests Requests Pending",
        "group": "cassandra",
        "label": "TP: Native Transport Requests Pending",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=transport,scope=Native-Transport-Requests,name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getNativeTransportRequestsPending",
        "type": "jmx"
    },
    "active-flushes": {
        "aggregation_type": "counter",
        "api_key": "active-flushes",
        "description": "Number of memtables being flushed flush process. A flush sorts and writes the memtables to disk, which could block writes.",
        "group": "cassandra",
        "label": "TP: Flushes Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=FlushWriter,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getFlushesActive",
        "type": "jmx"
    },
    "active-gossip-stage": {
        "aggregation_type": "counter",
        "api_key": "active-gossip-stage",
        "description": "Number of gossip messages and acknowledgments actively being sent or received.",
        "group": "cassandra",
        "label": "TP: Gossip Tasks Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=GossipStage,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getGossipStageActive",
        "type": "jmx"
    },
    "active-hinted-handoff": {
        "aggregation_type": "counter",
        "api_key": "active-hinted-handoff",
        "description": "Number of hints actively being delivered after a failed node comes up.",
        "group": "cassandra",
        "label": "TP: Hinted Handoff Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=HintedHandoff,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getHHActive",
        "type": "jmx"
    },
    "active-internal-response-stage": {
        "aggregation_type": "counter",
        "api_key": "active-internal-response-stage",
        "description": "Number of active tasks from internal tasks, such as nodes joining and leaving the cluster.",
        "group": "cassandra",
        "label": "TP: Internal Responses Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=InternalResponseStage,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getInternRespStageActive",
        "type": "jmx"
    },
    "active-anti-entropy-stage": {
        "aggregation_type": "counter",
        "api_key": "active-anti-entropy-stage",
        "description": "Repair tasks active, such as handling the merkle tree transfer after the validation compaction.",
        "group": "cassandra",
        "label": "TP: Manual Repair Tasks Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=AntiEntropyStage,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getAesActiveTasks",
        "type": "jmx"
    },
    "active-cache-cleanup-stage": {
        "aggregation_type": "counter",
        "api_key": "active-cache-cleanup-stage",
        "description": "Tasks to clean row caches during a cleanup compaction.",
        "group": "cassandra",
        "label": "TP: Cache Cleaning Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=CacheCleanupExecutor,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "type": "jmx"
    },
    "active-memtable-post-flush": {
        "aggregation_type": "counter",
        "api_key": "active-memtable-post-flush",
        "description": "Number of active tasks related to the last step in flushing memtables to disk as SSTables. Includes removing unnecessary commitlog files and committing Solr-based secondary indexes.",
        "group": "cassandra",
        "label": "TP: Memtable Post Flushers Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemtablePostFlusher,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMemtablePostFlusherActive",
        "type": "jmx"
    },
    "active-migration-stage": {
        "aggregation_type": "counter",
        "api_key": "active-migration-stage",
        "description": "Number of active tasks from system methods that modified the schema.",
        "group": "cassandra",
        "label": "TP: Migrations Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MigrationStage,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMigrationStageActive",
        "type": "jmx"
    },
    "active-misc-stage": {
        "aggregation_type": "counter",
        "api_key": "active-misc-stage",
        "description": "Number of active tasks from infrequently run operations, such as taking a snapshot or processing the notification of a completed replication.",
        "group": "cassandra",
        "label": "TP: Misc. Tasks Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MiscStage,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMiscStageActive",
        "type": "jmx"
    },
    "active-read-stage": {
        "aggregation_type": "counter",
        "api_key": "active-read-stage",
        "description": "Number of active read requests. Read requests read data off of disk and deserialize cached data.",
        "group": "cassandra",
        "label": "TP: Read Requests Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReadStage,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getReadStageActive",
        "type": "jmx"
    },
    "active-read-repair-stage": {
        "aggregation_type": "counter",
        "api_key": "active-read-repair-stage",
        "description": "Number of read repair operations actively being run.",
        "group": "cassandra",
        "label": "TP: Read Repair Tasks Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReadRepairStage,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getReadRepairStageActive",
        "type": "jmx"
    },
    "active-repl-on-write-tasks": {
        "aggregation_type": "counter",
        "api_key": "active-repl-on-write-tasks",
        "description": "Number of active counter increment tasks that will read then write on the replicas after a coordinator's local write. Depending on consistency level used on writes, tasks may back up outside of the normal write path.",
        "group": "cassandra",
        "label": "TP: Repl. on Write Tasks Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReplicateOnWriteStage,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getReplOnWriteStageActive",
        "type": "jmx"
    },
    "active-request-response-stage": {
        "aggregation_type": "counter",
        "api_key": "active-request-response-stage",
        "description": "Number of callbacks to being executed after a task on a remote node is completed.",
        "group": "cassandra",
        "label": "TP: Request Responses Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=RequestResponseStage,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getRequestResponseStageActive",
        "type": "jmx"
    },
    "active-mutation-stage": {
        "aggregation_type": "counter",
        "api_key": "active-mutation-stage",
        "description": "Number of write requests being handled.",
        "group": "cassandra",
        "label": "TP: Write Requests Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=MutationStage,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "type": "jmx"
    },
    "active-memory-meter": {
        "aggregation_type": "counter",
        "api_key": "active-memory-meter",
        "description": "Active tasks that calculate the live ratio which is used to estimate memtable size. The live ratio is the actual memory usage of a memtable including JVM overhead as it compares it to the raw data size. There will be at most one pending task per table.",
        "group": "cassandra",
        "label": "TP: Memory Meter Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemoryMeter,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMemoryMeterActive",
        "type": "jmx"
    },
    "active-validation-executor": {
        "aggregation_type": "counter",
        "api_key": "active-validation-executor",
        "description": "Active task to read data from sstables and generate a merkle tree for a repair.",
        "group": "cassandra",
        "label": "TP: Validation Executor Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=ValidationExecutor,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getValidationExecutorActive",
        "type": "jmx"
    },
    "active-compaction-executor": {
        "aggregation_type": "counter",
        "api_key": "active-compaction-executor",
        "description": "Active compactions that are known.",
        "group": "cassandra",
        "label": "TP: Compaction Executor Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=CompactionExecutor,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getCompactionExecutorActive",
        "type": "jmx"
    },
    "active-pending-range-calculator": {
        "aggregation_type": "counter",
        "api_key": "active-pending-range-calculator",
        "description": "Active tasks to calculate the ranges according to bootstrapping and leaving nodes.",
        "group": "cassandra",
        "label": "TP: Pending Range Calculator Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=PendingRangeCalculator,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getPendingRangeCalculatorActive",
        "type": "jmx"
    },
    "active-native-transport-requests": {
        "aggregation_type": "counter",
        "api_key": "active-native-transport-requests",
        "description": "Native Transport Requests Requests Active",
        "group": "cassandra",
        "label": "TP: Native Transport Requests Active",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=transport,scope=Native-Transport-Requests,name=ActiveTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getNativeTransportRequestsActive",
        "type": "jmx"
    },
    "completed-flushes": {
        "aggregation_type": "counter",
        "api_key": "completed-flushes",
        "description": "Number of memtables recently flushed. A flush sorts and writes the memtables to disk, which could block writes.",
        "group": "cassandra",
        "label": "TP: Flushes Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=FlushWriter,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getFlushesCompleted",
        "type": "jmx"
    },
    "completed-gossip-stage": {
        "aggregation_type": "counter",
        "api_key": "completed-gossip-stage",
        "description": "Number of gossip messages and acknowledgments recently sent or received.",
        "group": "cassandra",
        "label": "TP: Gossip Tasks Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=GossipStage,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getGossipStageCompleted",
        "type": "jmx"
    },
    "completed-hinted-handoff": {
        "aggregation_type": "counter",
        "api_key": "completed-hinted-handoff",
        "description": "Number of hints recently delivered after a failed node comes up.",
        "group": "cassandra",
        "label": "TP: Hinted Handoff Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=HintedHandoff,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getHHCompleted",
        "type": "jmx"
    },
    "completed-internal-response-stage": {
        "aggregation_type": "counter",
        "api_key": "completed-internal-response-stage",
        "description": "Number of recently completed tasks from internal tasks, such as nodes joining and leaving the cluster.",
        "group": "cassandra",
        "label": "TP: Internal Responses Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=InternalResponseStage,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getInternRespStageCompleted",
        "type": "jmx"
    },
    "completed-anti-entropy-stage": {
        "aggregation_type": "counter",
        "api_key": "completed-anti-entropy-stage",
        "description": "Repair tasks recently completed, such as handling the merkle tree transfer after the validation compaction.",
        "group": "cassandra",
        "label": "TP: Manual Repair Tasks Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=AntiEntropyStage,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getAesCompletedTasks",
        "type": "jmx"
    },
    "completed-cache-cleanup-stage": {
        "aggregation_type": "counter",
        "api_key": "completed-cache-cleanup-stage",
        "description": "Tasks to clean row caches during a cleanup compaction.",
        "group": "cassandra",
        "label": "TP: Cache Cleaning Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=CacheCleanupExecutor,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "type": "jmx"
    },
    "completed-memtable-post-flush": {
        "aggregation_type": "counter",
        "api_key": "completed-memtable-post-flush",
        "description": "Number of completed tasks related to the last step in flushing memtables to disk as SSTables. Includes removing unnecessary commitlog files and committing Solr-based secondary indexes.",
        "group": "cassandra",
        "label": "TP: Memtable Post Flushers Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemtablePostFlusher,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMemtablePostFlusherCompleted",
        "type": "jmx"
    },
    "completed-migration-stage": {
        "aggregation_type": "counter",
        "api_key": "completed-migration-stage",
        "description": "Number of completed tasks from system methods that modified the schema.",
        "group": "cassandra",
        "label": "TP: Migrations Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MigrationStage,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMigrationStageCompleted",
        "type": "jmx"
    },
    "completed-misc-stage": {
        "aggregation_type": "counter",
        "api_key": "completed-misc-stage",
        "description": "Number of completed tasks from infrequently run operations, such as taking a snapshot or processing the notification of a completed replication.",
        "group": "cassandra",
        "label": "TP: Misc. Tasks Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MiscStage,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMiscStageCompleted",
        "type": "jmx"
    },
    "completed-read-stage": {
        "aggregation_type": "counter",
        "api_key": "completed-read-stage",
        "description": "Number of completed read requests. Read requests read data off of disk and deserialize cached data.",
        "group": "cassandra",
        "label": "TP: Read Requests Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReadStage,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getReadStageCompleted",
        "type": "jmx"
    },
    "completed-read-repair-stage": {
        "aggregation_type": "counter",
        "api_key": "completed-read-repair-stage",
        "description": "Number of read repair operations recently completed.",
        "group": "cassandra",
        "label": "TP: Read Repair Tasks Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReadRepairStage,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getReadRepairStageCompleted",
        "type": "jmx"
    },
    "completed-repl-on-write-tasks": {
        "aggregation_type": "counter",
        "api_key": "completed-repl-on-write-tasks",
        "description": "Number of completed counter increment tasks that read then write on the replicas after a coordinator's local write. Depending on consistency level used on writes, tasks may back up outside of the normal write path.",
        "group": "cassandra",
        "label": "TP: Repl. on Write Tasks Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReplicateOnWriteStage,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getReplOnWriteStageCompleted",
        "type": "jmx"
    },
    "completed-request-response-stage": {
        "aggregation_type": "counter",
        "api_key": "completed-request-response-stage",
        "description": "Number of completed callbacks executed after a task on a remote node is completed.",
        "group": "cassandra",
        "label": "TP: Request Responses Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=RequestResponseStage,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getRequestResponseStageCompleted",
        "type": "jmx"
    },
    "completed-mutation-stage": {
        "aggregation_type": "counter",
        "api_key": "completed-mutation-stage",
        "description": "Number of write requests received by the cluster that have been handled.",
        "group": "cassandra",
        "label": "TP: Write Requests Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=MutationStage,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMutationStageCompleted",
        "type": "jmx"
    },
    "completed-memory-meter": {
        "aggregation_type": "counter",
        "api_key": "completed-memory-meter",
        "description": "Completed tasks that calculate the live ratio which is used to estimate memtable size. The live ratio is the actual memory usage of a memtable including JVM overhead as it compares it to the raw data size. There will be at most one pending task per table.",
        "group": "cassandra",
        "label": "TP: Memory Meter Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemoryMeter,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMemoryMeterCompleted",
        "type": "jmx"
    },
    "completed-validation-executor": {
        "aggregation_type": "counter",
        "api_key": "completed-validation-executor",
        "description": "Completed tasks to read data from sstables and generate a merkle tree for a repair.",
        "group": "cassandra",
        "label": "TP: Validation Executor Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=ValidationExecutor,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getValidationExecutorCompleted",
        "type": "jmx"
    },
    "completed-compaction-executor": {
        "aggregation_type": "counter",
        "api_key": "completed-compaction-executor",
        "description": "Completed compactions.",
        "group": "cassandra",
        "label": "TP: Compaction Executor Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=CompactionExecutor,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getCompactionExecutorCompleted",
        "type": "jmx"
    },
    "completed-pending-range-calculator": {
        "aggregation_type": "counter",
        "api_key": "completed-pending-range-calculator",
        "description": "Completed tasks to calculate the ranges according to bootstrapping and leaving nodes.",
        "group": "cassandra",
        "label": "TP: Pending Range Calculator Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=PendingRangeCalculator,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getPendingRangeCalculatorCompleted",
        "type": "jmx"
    },
    "completed-native-transport-requests": {
        "aggregation_type": "counter",
        "api_key": "completed-native-transport-requests",
        "description": "Native Transport Requests Requests Completed",
        "group": "cassandra",
        "label": "TP: Native Transport Requests Completed",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=transport,scope=Native-Transport-Requests,name=CompletedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getNativeTransportRequestsCompleted",
        "type": "jmx"
    },
    "blocked-flushes": {
        "aggregation_type": "counter",
        "api_key": "blocked-flushes",
        "description": "Number of memtables flush process blocked, this occurs when there are over memtable_flush_queue_size pending flushes. A flush sorts and writes the memtables to disk, this will block writes.",
        "group": "cassandra",
        "label": "TP: Flushes Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=FlushWriter,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getFlushesBlocked",
        "type": "jmx"
    },
    "blocked-gossip-stage": {
        "aggregation_type": "counter",
        "api_key": "blocked-gossip-stage",
        "description": "Number of gossip messages and acknowledgments blocked waiting to be sent or received.",
        "group": "cassandra",
        "label": "TP: Gossip Tasks Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=GossipStage,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getGossipStageBlocked",
        "type": "jmx"
    },
    "blocked-hinted-handoff": {
        "aggregation_type": "counter",
        "api_key": "blocked-hinted-handoff",
        "description": "Number of hints blocked waiting to be delivered after a failed node comes up.",
        "group": "cassandra",
        "label": "TP: Hinted Handoff Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=HintedHandoff,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getHHBlocked",
        "type": "jmx"
    },
    "blocked-internal-response-stage": {
        "aggregation_type": "counter",
        "api_key": "blocked-internal-response-stage",
        "description": "Number of blocked tasks from internal tasks, such as nodes joining and leaving the cluster.",
        "group": "cassandra",
        "label": "TP: Internal Responses Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=InternalResponseStage,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getInternRespStageBlocked",
        "type": "jmx"
    },
    "blocked-anti-entropy-stage": {
        "aggregation_type": "counter",
        "api_key": "blocked-anti-entropy-stage",
        "description": "Repair tasks blocked, such as handling the merkle tree transfer after the validation compaction.",
        "group": "cassandra",
        "label": "TP: Manual Repair Tasks Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=AntiEntropyStage,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getAesBlockedTasks",
        "type": "jmx"
    },
    "blocked-cache-cleanup-stage": {
        "aggregation_type": "counter",
        "api_key": "blocked-cache-cleanup-stage",
        "description": "Tasks to clean row caches during a cleanup compaction.",
        "group": "cassandra",
        "label": "TP: Cache Cleaning Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=CacheCleanupExecutor,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "type": "jmx"
    },
    "blocked-memtable-post-flush": {
        "aggregation_type": "counter",
        "api_key": "blocked-memtable-post-flush",
        "description": "Number of blocked tasks related to the last step in flushing memtables to disk as SSTables. Includes removing unnecessary commitlog files and committing Solr-based secondary indexes.",
        "group": "cassandra",
        "label": "TP: Memtable Post Flushers Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemtablePostFlusher,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMemtablePostFlusherBlocked",
        "type": "jmx"
    },
    "blocked-migration-stage": {
        "aggregation_type": "counter",
        "api_key": "blocked-migration-stage",
        "description": "Number of blocked tasks from system methods that modified the schema.",
        "group": "cassandra",
        "label": "TP: Migrations Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MigrationStage,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMigrationStageBlocked",
        "type": "jmx"
    },
    "blocked-misc-stage": {
        "aggregation_type": "counter",
        "api_key": "blocked-misc-stage",
        "description": "Number of blocked tasks from infrequently run operations, such as taking a snapshot or processing the notification of a completed replication.",
        "group": "cassandra",
        "label": "TP: Misc. Tasks Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MiscStage,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMiscStageBlocked",
        "type": "jmx"
    },
    "blocked-read-stage": {
        "aggregation_type": "counter",
        "api_key": "blocked-read-stage",
        "description": "Number of blocked read requests. Read requests read data off of disk and deserialize cached data.",
        "group": "cassandra",
        "label": "TP: Read Requests Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReadStage,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getReadStageBlocked",
        "type": "jmx"
    },
    "blocked-read-repair-stage": {
        "aggregation_type": "counter",
        "api_key": "blocked-read-repair-stage",
        "description": "Number of read repair operations blocked waiting to run.",
        "group": "cassandra",
        "label": "TP: Read Repair Tasks Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReadRepairStage,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getReadRepairStageBlocked",
        "type": "jmx"
    },
    "blocked-repl-on-write-tasks": {
        "aggregation_type": "counter",
        "api_key": "blocked-repl-on-write-tasks",
        "description": "Number of blocked counter increment tasks that occurs when there are over 1024 * processors pending tasks. These tasks will read then write on the replicas after a coordinator's local write. Depending on consistency level used on writes, tasks may back up outside of the normal write path.",
        "group": "cassandra",
        "label": "TP: Repl. on Write Tasks Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReplicateOnWriteStage,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getReplOnWriteStageBlocked",
        "type": "jmx"
    },
    "blocked-request-response-stage": {
        "aggregation_type": "counter",
        "api_key": "blocked-request-response-stage",
        "description": "Number of blocked callbacks to be executed after a task on a remote node is completed.",
        "group": "cassandra",
        "label": "TP: Request Responses Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=RequestResponseStage,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getRequestResponseStageBlocked",
        "type": "jmx"
    },
    "blocked-mutation-stage": {
        "aggregation_type": "counter",
        "api_key": "blocked-mutation-stage",
        "description": "Number of write requests received by the cluster and blocked waiting to be handled.",
        "group": "cassandra",
        "label": "TP: Write Requests Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=MutationStage,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMutationStageBlocked",
        "type": "jmx"
    },
    "blocked-memory-meter": {
        "aggregation_type": "counter",
        "api_key": "blocked-memory-meter",
        "description": "Memory Meter Blocked",
        "group": "cassandra",
        "label": "TP: Memory Meter Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemoryMeter,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMemoryMeterBlocked",
        "type": "jmx"
    },
    "blocked-validation-executor": {
        "aggregation_type": "counter",
        "api_key": "blocked-validation-executor",
        "description": "Validation Executor Blocked",
        "group": "cassandra",
        "label": "TP: Validation Executor Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=ValidationExecutor,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getValidationExecutorBlocked",
        "type": "jmx"
    },
    "blocked-compaction-executor": {
        "aggregation_type": "counter",
        "api_key": "blocked-compaction-executor",
        "description": "Compaction Executor Blocked",
        "group": "cassandra",
        "label": "TP: Compaction Executor Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=CompactionExecutor,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getCompactionExecutorBlocked",
        "type": "jmx"
    },
    "blocked-pending-range-calculator": {
        "aggregation_type": "counter",
        "api_key": "blocked-pending-range-calculator",
        "description": "Pending Range Calculator Blocked",
        "group": "cassandra",
        "label": "TP: Pending Range Calculator Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=PendingRangeCalculator,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getPendingRangeCalculatorBlocked",
        "type": "jmx"
    },
    "blocked-native-transport-requests": {
        "aggregation_type": "counter",
        "api_key": "blocked-native-transport-requests",
        "description": "Native Transport Requests Requests Blocked",
        "group": "cassandra",
        "label": "TP: Native Transport Requests Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=transport,scope=Native-Transport-Requests,name=CurrentlyBlockedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getNativeTransportRequestsBlocked",
        "type": "jmx"
    },
    "total-blocked-flushes": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-flushes",
        "description": "Total number of memtables flush process blocked. A flush sorts and writes the memtables to disk, which could block writes.",
        "group": "cassandra",
        "label": "TP: Total Flushes Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=FlushWriter,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getFlushesTotalBlocked",
        "type": "jmx"
    },
    "total-blocked-gossip-stage": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-gossip-stage",
        "description": "Total number of gossip messages and acknowledgments blocked waiting to be sent or received.",
        "group": "cassandra",
        "label": "TP: Total Gossip Tasks Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=GossipStage,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getGossipStageTotalBlocked",
        "type": "jmx"
    },
    "total-blocked-hinted-handoff": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-hinted-handoff",
        "description": "Total number of hints blocked waiting to be delivered after a failed node comes up.",
        "group": "cassandra",
        "label": "TP: Total Hinted Handoff Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=HintedHandoff,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getHHTotalBlocked",
        "type": "jmx"
    },
    "total-blocked-internal-response-stage": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-internal-response-stage",
        "description": "Total number of blocked tasks from internal tasks, such as nodes joining and leaving the cluster.",
        "group": "cassandra",
        "label": "TP: Total Internal Responses Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=InternalResponseStage,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getInternRespStageTotalBlocked",
        "type": "jmx"
    },
    "total-blocked-anti-entropy-stage": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-anti-entropy-stage",
        "description": "Total repair tasks blocked, such as handling the merkle tree transfer after the validation compaction.",
        "group": "cassandra",
        "label": "TP: Total Manual Repair Tasks Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=AntiEntropyStage,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getAesTotalBlockedTasks",
        "type": "jmx"
    },
    "total-blocked-cache-cleanup-stage": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-cache-cleanup-stage",
        "description": "Tasks to clean row caches during a cleanup compaction.",
        "group": "cassandra",
        "label": "TP: Total Cache Cleaning Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=CacheCleanupExecutor,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "type": "jmx"
    },
    "total-blocked-memtable-post-flush": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-memtable-post-flush",
        "description": "Total number of blocked tasks related to the last step in flushing memtables to disk as SSTables. Includes removing unnecessary commitlog files and committing Solr-based secondary indexes.",
        "group": "cassandra",
        "label": "TP: Total Memtable Post Flushers Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemtablePostFlusher,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMemtablePostFlusherTotalBlocked",
        "type": "jmx"
    },
    "total-blocked-migration-stage": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-migration-stage",
        "description": "Total number of blocked tasks from system methods that modified the schema.",
        "group": "cassandra",
        "label": "TP: Total Migrations Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MigrationStage,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMigrationStageTotalBlocked",
        "type": "jmx"
    },
    "total-blocked-misc-stage": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-misc-stage",
        "description": "Total number of blocked tasks from infrequently run operations, such as taking a snapshot or processing the notification of a completed replication.",
        "group": "cassandra",
        "label": "TP: Total Misc. Tasks Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MiscStage,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMiscStageTotalBlocked",
        "type": "jmx"
    },
    "total-blocked-read-stage": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-read-stage",
        "description": "Total number of blocked read requests. Read requests read data off of disk and deserialize cached data.",
        "group": "cassandra",
        "label": "TP: Total Read Requests Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReadStage,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getReadStageTotalBlocked",
        "type": "jmx"
    },
    "total-blocked-read-repair-stage": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-read-repair-stage",
        "description": "Total number of read repair operations blocked waiting to run.",
        "group": "cassandra",
        "label": "TP: Total Read Repair Tasks Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReadRepairStage,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getReadRepairStageTotalBlocked",
        "type": "jmx"
    },
    "total-blocked-repl-on-write-tasks": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-repl-on-write-tasks",
        "description": "Total number of blocked counter increment tasks that will read then write on the replicas after a coordinator's local write. Depending on consistency level used on writes, tasks may back up outside of the normal write path.",
        "group": "cassandra",
        "label": "TP: Total Repl. on Write Tasks Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=ReplicateOnWriteStage,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getReplOnWriteStageTotalBlocked",
        "type": "jmx"
    },
    "total-blocked-request-response-stage": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-request-response-stage",
        "description": "Total number of blocked callbacks to be executed after a task on a remote node is completed.",
        "group": "cassandra",
        "label": "TP: Total Request Responses Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=RequestResponseStage,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getRequestResponseStageTotalBlocked",
        "type": "jmx"
    },
    "total-blocked-mutation-stage": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-mutation-stage",
        "description": "Total number of write requests received by the cluster and blocked waiting to be handled.",
        "group": "cassandra",
        "label": "TP: Total Write Requests Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=request,scope=MutationStage,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMutationStageTotalBlocked",
        "type": "jmx"
    },
    "total-blocked-memory-meter": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-memory-meter",
        "description": "Total Memory Meter Blocked",
        "group": "cassandra",
        "label": "TP: Total Memory Meter Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=MemoryMeter,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getMemoryMeterTotalBlocked",
        "type": "jmx"
    },
    "total-blocked-validation-executor": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-validation-executor",
        "description": "Total Validation Executor Blocked",
        "group": "cassandra",
        "label": "TP: Total Validation Executor Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=ValidationExecutor,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getValidationExecutorTotalBlocked",
        "type": "jmx"
    },
    "total-blocked-compaction-executor": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-compaction-executor",
        "description": "Total Compaction Executor Blocked",
        "group": "cassandra",
        "label": "TP: Total Compaction Executor Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=CompactionExecutor,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getCompactionExecutorTotalBlocked",
        "type": "jmx"
    },
    "total-blocked-pending-range-calculator": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-pending-range-calculator",
        "description": "Total Pending Range Calculator Blocked",
        "group": "cassandra",
        "label": "TP: Total Pending Range Calculator Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=internal,scope=PendingRangeCalculator,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Count"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getPendingRangeCalculatorTotalBlocked",
        "type": "jmx"
    },
    "total-blocked-native-transport-requests": {
        "aggregation_type": "counter",
        "api_key": "total-blocked-native-transport-requests",
        "description": "Total Native Transport Requests Requests Blocked",
        "group": "cassandra",
        "label": "TP: Total Native Transport Requests Blocked",
        "mbean": "org.apache.cassandra.metrics:type=ThreadPools,path=transport,scope=Native-Transport-Requests,name=TotalBlockedTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "priority": 30,
        "scope": "general",
        "storage_name": "getNativeTransportRequestsTotalBlocked",
        "type": "jmx"
    },
    "key-cache-hits": {
        "aggregation_type": "average",
        "api_key": "key-cache-hits",
        "description": "The number of key cache hits per second. This will avoid possible disk seeks when finding a partition in an SSTable. This metric only applies to SSTables created by DSE versions earlier than 6.0.",
        "group": "cassandra",
        "label": "KeyCache Hits",
        "mbean": "org.apache.cassandra.metrics:type=Cache,scope=KeyCache,name=Hits",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 35,
        "scope": "general",
        "storage_name": "getKeyCacheHits",
        "type": "jmx",
        "unit": "/sec"
    },
    "key-cache-requests": {
        "aggregation_type": "average",
        "api_key": "key-cache-requests",
        "description": "The number of key cache requests per second. This metric only applies to SSTables created by DSE versions earlier than 6.0.",
        "group": "cassandra",
        "label": "KeyCache Requests",
        "mbean": "org.apache.cassandra.metrics:type=Cache,scope=KeyCache,name=Requests",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 35,
        "scope": "general",
        "storage_name": "getKeyCacheRequests",
        "type": "jmx",
        "unit": "/sec"
    },
    "key-cache-hit-rate": {
        "aggregation_type": "average",
        "api_key": "key-cache-hit-rate",
        "description": "The percentage of key cache lookups that resulted in a hit.",
        "from_unit": "fromPercentage",
        "group": "cassandra",
        "label": "KeyCache Hit Rate",
        "mbean": "org.apache.cassandra.db:type=Caches",
        "metric_type": "gauge",
        "path": ["KeyCacheRecentHitRate"],
        "priority": 35,
        "scope": "general",
        "storage_name": "getKeyCacheRecentHitRate",
        "to_unit": "toPercentage",
        "type": "jmx",
        "render_type": "percentage"
    },
    "row-cache-hits": {
        "aggregation_type": "average",
        "api_key": "row-cache-hits",
        "description": "The number of row cache hits per second.",
        "group": "cassandra",
        "label": "RowCache Hits",
        "mbean": "org.apache.cassandra.metrics:type=Cache,scope=RowCache,name=Hits",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 35,
        "scope": "general",
        "storage_name": "getRowCacheHits",
        "type": "jmx",
        "unit": "/sec"
    },
    "row-cache-requests": {
        "aggregation_type": "average",
        "api_key": "row-cache-requests",
        "description": "The number of row cache requests per second.",
        "group": "cassandra",
        "label": "RowCache Requests",
        "mbean": "org.apache.cassandra.metrics:type=Cache,scope=RowCache,name=Requests",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 35,
        "scope": "general",
        "storage_name": "getRowCacheRequests",
        "type": "jmx",
        "unit": "/sec"
    },
    "row-cache-hit-rate": {
        "aggregation_type": "average",
        "api_key": "row-cache-hit-rate",
        "description": "The percentage of row cache lookups that resulted in a hit.",
        "from_unit": "fromPercentage",
        "group": "cassandra",
        "label": "RowCache Hit Rate",
        "mbean": "org.apache.cassandra.db:type=Caches",
        "metric_type": "gauge",
        "path": ["RowCacheRecentHitRate"],
        "priority": 35,
        "scope": "general",
        "storage_name": "getRowCacheRecentHitRate",
        "to_unit": "toPercentage",
        "type": "jmx",
        "render_type": "percentage"
    },
    "native-connections": {
        "aggregation_type": "counter",
        "api_key": "native-connections",
        "description": "The number of clients connected using the native protocol.",
        "group": "cassandra",
        "label": "Native Clients",
        "mbean": "org.apache.cassandra.metrics:type=Client,name=connectedNativeClients",
        "metric_type": "gauge",
        "min-version": "1.2.11",
        "path": ["Value"],
        "priority": 40,
        "scope": "general",
        "storage_name": "getNativeClientCount",
        "type": "jmx"
    },
    "thrift-connections": {
        "aggregation_type": "counter",
        "api_key": "thrift-connections",
        "description": "The number of clients connected via thrift.",
        "group": "cassandra",
        "label": "Thrift Clients",
        "mbean": "org.apache.cassandra.metrics:type=Client,name=connectedThriftClients",
        "metric_type": "gauge",
        "min-version": "1.2.11",
        "path": ["Value"],
        "priority": 40,
        "scope": "general",
        "storage_name": "getThriftClientCount",
        "type": "jmx"
    },
    "read-repair-attempted": {
        "aggregation_type": "counter",
        "api_key": "read-repair-attempted",
        "description": "Number of read requests where the number of nodes queried possibly exceeds the consistency level requested in order to check for a possible digest mismatch.",
        "group": "cassandra",
        "label": "Read Repairs Attempted",
        "mbean": "org.apache.cassandra.metrics:type=ReadRepair,name=Attempted",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 45,
        "scope": "general",
        "storage_name": "getReadRepairAttempted",
        "type": "jmx",
        "unit": "/sec"
    },
    "read-repaired-background": {
        "aggregation_type": "counter",
        "api_key": "read-repaired-background",
        "description": "Corresponds to a digest mismatch that occurred after a completed read, outside of the client read loop.",
        "group": "cassandra",
        "label": "Asynchronous Read Repairs",
        "mbean": "org.apache.cassandra.metrics:type=ReadRepair,name=RepairedBackground",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 45,
        "scope": "general",
        "storage_name": "getReadRepairedBackground",
        "type": "jmx",
        "unit": "/sec"
    },
    "read-repaired-blocking": {
        "aggregation_type": "counter",
        "api_key": "read-repaired-blocking",
        "description": "Corresponds to the number of times there was a digest mismatch within the requested consistency level and a full data read was started.",
        "group": "cassandra",
        "label": "Synchronous Read Repairs",
        "mbean": "org.apache.cassandra.metrics:type=ReadRepair,name=RepairedBlocking",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 45,
        "scope": "general",
        "storage_name": "getReadRepairedBlocking",
        "type": "jmx",
        "unit": "/sec"
    },
    "cf-write-ops": {
        "aggregation_type": "counter",
        "alerts_label": "Local Writes",
        "api_key": "cf-write-ops",
        "is_table_metric": true,
        "description": "Local write requests per second. Local writes update the table's memtable and appends to a commitlog.",
        "group": "cf",
        "label": "TBL: Local Writes",
        "mbean": "org.apache.cassandra.metrics:type=ColumnFamily,keyspace={keyspace},scope={table},name=WriteLatency",
        "metric_type": "derive",
        "path": ["Count"],
        "scope": "cf",
        "storage_name": "getWriteCount",
        "type": "jmx",
        "unit": "/sec"
    },
    "cf-write-latency-op": {
        "aggregation_type": "average",
        "alerts_label": "Local Write Latency",
        "api_key": "cf-write-latency-op",
        "is_table_metric": true,
        "description": "Average response time to write data to a table's memtable. The elapsed time from when the replica receives the request from a coordinator and returns a response.",
        "from_unit": "msToMicros",
        "group": "cf",
        "label": "TBL: Local Write Latency",
        "mbean": "org.apache.cassandra.db:type=ColumnFamilies,keyspace={keyspace},columnfamily={table}",
        "metric_type": "gauge",
        "minstep": 0.1,
        "path": ["RecentWriteLatencyMicros"],
        "scope": "cf",
        "storage_name": "getRecentWriteLatencyMicros",
        "to_unit": "microsToMs",
        "type": "jmx",
        "unit": "ms/op"
    },
    "cf-local-write-latency": {
        "aggregation_type": "histogram",
        "alerts_label": "Local Write Latency (percentiles)",
        "allow_alerts": true,
        "api_key": "cf-local-write-latency",
        "is_table_metric": true,
        "description": "The min, median, max, 90th, and 99th percentile of the response times to write data to a table's memtable. The elapsed time from when the replica receives the request from a coordinator and returns a response.",
        "group": "cf",
        "histogram": true,
        "label": "TBL: Local Write Latency (percentiles)",
        "label_func": "logLabel",
        "max": "<b>Max</b> - The maximum latency during a time interval.",
        "mbean": "org.apache.cassandra.db:type=ColumnFamilies,keyspace={keyspace},columnfamily={table}",
        "median": "<b>Median</b> - The median, also known as the 50th percentile, represents a value where 50 percent of values during a time interval are either at or below the median value.",
        "metric_type": "histogram",
        "min": "<b>Min</b> - The minimum latency during a time interval.",
        "p90th": "<b>90th</b> - The 90th percentile represents a value where 90 percent of values during a time interval are at or below, and 10 percent of values are above, the 90th percentile value.",
        "p99th": "<b>99th</b> - The 99th percentile represents a value where 99 percent of values during a time interval are at or below, and 1 percent of values are above, the 99th percentile value.",
        "path": ["LifetimeWriteLatencyHistogramMicros"],
        "plot": "Areas",
        "scale": "logScale",
        "scope": "cf",
        "storage_name": "getCFLocalWriteLatency",
        "to_unit": "microsToMs",
        "from_unit": "msToMicros",
        "type": "jmx",
        "unit": "ms/op"
    },
    "cf-read-ops": {
        "aggregation_type": "counter",
        "alerts_label": "Local Reads",
        "api_key": "cf-read-ops",
        "is_table_metric": true,
        "description": "Local read requests per second. Local reads retrieve data from a table's memtable and any necessary SSTables on disk.",
        "group": "cf",
        "label": "TBL: Local Reads",
        "mbean": "org.apache.cassandra.metrics:type=ColumnFamily,keyspace={keyspace},scope={table},name=ReadLatency",
        "metric_type": "derive",
        "path": ["Count"],
        "scope": "cf",
        "storage_name": "getReadCount",
        "type": "jmx",
        "unit": "/sec"
    },
    "cf-read-latency-op": {
        "aggregation_type": "average",
        "alerts_label": "Local Read Latency",
        "api_key": "cf-read-latency-op",
        "is_table_metric": true,
        "description": "Average response time to read data from the memtable and SSTables for a specific table. The elapsed time from when the replica receives the request from a coordinator and returns a response.",
        "from_unit": "msToMicros",
        "group": "cf",
        "label": "TBL: Local Read Latency",
        "mbean": "org.apache.cassandra.db:type=ColumnFamilies,keyspace={keyspace},columnfamily={table}",
        "metric_type": "gauge",
        "minstep": 0.1,
        "path": ["RecentReadLatencyMicros"],
        "scope": "cf",
        "storage_name": "getRecentReadLatencyMicros",
        "to_unit": "microsToMs",
        "type": "jmx",
        "unit": "ms/op"
    },
    "cf-local-read-latency": {
        "aggregation_type": "histogram",
        "alerts_label": "Local Read Latency (percentiles)",
        "allow_alerts": true,
        "api_key": "cf-local-read-latency",
        "is_table_metric": true,
        "description": "The min, median, max, 90th, and 99th percentile of the response time to read data from the memtable and sstables for a specific table. The elapsed time from when the replica receives the request from a coordinator and returns a response.",
        "group": "cf",
        "histogram": true,
        "label": "TBL: Local Read Latency (percentiles)",
        "label_func": "logLabel",
        "max": "<b>Max</b> - The maximum latency during a time interval.",
        "mbean": "org.apache.cassandra.db:type=ColumnFamilies,keyspace={keyspace},columnfamily={table}",
        "median": "<b>Median</b> - The median, also known as the 50th percentile, represents a value where 50 percent of values during a time interval are either at or below the median value.",
        "metric_type": "histogram",
        "min": "<b>Min</b> - The minimum latency during a time interval.",
        "p90th": "<b>90th</b> - The 90th percentile represents a value where 90 percent of values during a time interval are at or below, and 10 percent of values are above, the 90th percentile value.",
        "p99th": "<b>99th</b> - The 99th percentile represents a value where 99 percent of values during a time interval are at or below, and 1 percent of values are above, the 99th percentile value.",
        "path": ["LifetimeReadLatencyHistogramMicros"],
        "plot": "Areas",
        "scale": "logScale",
        "scope": "cf",
        "storage_name": "getCFLocalReadLatency",
        "to_unit": "microsToMs",
        "from_unit": "msToMicros",
        "type": "jmx",
        "unit": "ms/op"
    },
    "cf-live-disk-used": {
        "aggregation_type": "counter",
        "alerts_label": "Live Disk Used",
        "api_key": "cf-live-disk-used",
        "is_table_metric": true,
        "description": "Disk space used by live SSTables. There might be obsolete SSTables not included.",
        "from_unit": "gbToBytes",
        "group": "cf",
        "label": "TBL: Live Disk Used",
        "mbean": "org.apache.cassandra.metrics:type=ColumnFamily,keyspace={keyspace},scope={table},name=LiveDiskSpaceUsed",
        "metric_type": "gauge",
        "path": ["Count"],
        "postprocess": ["neg-to-nil"],
        "scope": "cf",
        "storage_name": "getLiveDiskSpaceUsed",
        "to_unit": "bytesToGb",
        "type": "jmx",
        "render_type": "filesize"
    },
    "cf-total-disk-used": {
        "aggregation_type": "counter",
        "alerts_label": "Total Disk Used",
        "api_key": "cf-total-disk-used",
        "is_table_metric": true,
        "description": "Disk space used by a table by SSTables, including obsolete ones waiting to be garbage collected.",
        "from_unit": "gbToBytes",
        "group": "cf",
        "label": "TBL: Total Disk Used",
        "mbean": "org.apache.cassandra.metrics:type=ColumnFamily,keyspace={keyspace},scope={table},name=TotalDiskSpaceUsed",
        "metric_type": "gauge",
        "path": ["Count"],
        "postprocess": ["neg-to-nil"],
        "scope": "cf",
        "storage_name": "getTotalDiskSpaceUsed",
        "to_unit": "bytesToGb",
        "type": "jmx",
        "render_type": "filesize"
    },
    "cf-live-sstables": {
        "aggregation_type": "counter",
        "alerts_label": "SSTable Count",
        "api_key": "cf-live-sstables",
        "is_table_metric": true,
        "description": "Total number of SSTables for a table.",
        "group": "cf",
        "label": "TBL: SSTable Count",
        "mbean": "org.apache.cassandra.metrics:type=ColumnFamily,keyspace={keyspace},scope={table},name=LiveSSTableCount",
        "metric_type": "gauge",
        "path": ["Value"],
        "scope": "cf",
        "storage_name": "getLiveSSTableCount",
        "type": "jmx"
    },
    "cf-sstables-per-read": {
        "aggregation_type": "histogram",
        "alerts_label": "SSTables per Read (percentiles)",
        "allow_alerts": true,
        "api_key": "cf-sstables-per-read",
        "is_table_metric": true,
        "description": "The min, median, max, 90th, and 99th percentile of how many SSTables are accessed during a read. Includes sstables that undergo bloom-filter checks, even if no data is read from the sstable.",
        "group": "cf",
        "histogram": true,
        "label": "TBL: SSTables per Read (percentiles)",
        "max": "<b>Max</b> - Maximum number of SSTables checked or read during this period for a single read on this table.",
        "mbean": "org.apache.cassandra.db:type=ColumnFamilies,keyspace={keyspace},columnfamily={table}",
        "median": "<b>Median</b> - 50 percent of reads checked or read no more than this many SSTables during the period.",
        "metric_type": "histogram",
        "min": "<b>Min</b> - Minimum number of SSTables checked or read during this period for a single read on this table.",
        "p90th": "<b>90th</b> - 90 percent of reads checked or read no more than this many SSTables during the period.",
        "p99th": "<b>99th</b> - 99 percent of reads checked or read no more than this many SSTables during the period.",
        "path": ["SSTablesPerReadHistogram"],
        "plot": "Areas",
        "scope": "cf",
        "storage_name": "getCFSSTablesPerRead",
        "type": "jmx",
        "unit": "sstables"
    },
    "cf-partition-size": {
        "aggregation_type": "histogram",
        "alerts_label": "Partition Size (percentiles)",
        "allow_alerts": true,
        "api_key": "cf-partition-size",
        "is_table_metric": true,
        "description": "The min, median, max, 90th, and 99th percentile of the size (in bytes) of partitions of this table.",
        "group": "cf",
        "histogram": true,
        "label": "TBL: Partition Size (percentiles)",
        "label_func": "logLabel",
        "max": "<b>Max</b> - Maximum size of a partition in bytes.",
        "mbean": "org.apache.cassandra.db:type=ColumnFamilies,keyspace={keyspace},columnfamily={table}",
        "median": "<b>Median</b> - 50 percent of partitions are no larger than this.",
        "metric_type": "histogram-gauge",
        "min": "<b>Min</b> - Minimum size of a partition in bytes",
        "p90th": "<b>90th</b> - 90 percent of partitions are no larger than this.",
        "p99th": "<b>99th</b> - 99 percent of partitions are no larger than this.",
        "path": ["EstimatedRowSizeHistogram"],
        "plot": "Areas",
        "scale": "logScale",
        "scope": "cf",
        "type": "jmx",
        "render_type": "var-filesize",
        "unit": ""
    },
    "cf-column-count": {
        "aggregation_type": "histogram",
        "alerts_label": "Cell Count (percentiles)",
        "allow_alerts": true,
        "api_key": "cf-column-count",
        "is_table_metric": true,
        "description": "The min, median, max, 90th, and 99th percentile of how many cells exist in partitions for this table.",
        "group": "cf",
        "histogram": true,
        "label": "TBL: Cell Count (percentiles)",
        "max": "<b>Max</b> - Maximum number of cells in a partition.",
        "mbean": "org.apache.cassandra.db:type=ColumnFamilies,keyspace={keyspace},columnfamily={table}",
        "median": "<b>Median</b> - 50 percent of partitions have no more than this many cells.",
        "metric_type": "histogram-gauge",
        "min": "<b>Min</b> - Minimum number of cells in a partition.",
        "p90th": "<b>90th</b> - 90 percent of partitions have no more than this many cells.",
        "p99th": "<b>99th</b> - 99 percent of partitions have no more than this many cells.",
        "path": ["EstimatedColumnCountHistogram"],
        "plot": "Areas",
        "scope": "cf",
        "type": "jmx",
        "unit": "cells"
    },
    "cf-pending-tasks": {
        "aggregation_type": "counter",
        "alerts_label": "Pending Reads/Writes",
        "api_key": "cf-pending-tasks",
        "is_table_metric": true,
        "description": "Estimate of the number of mutation threads blocked on a memtable flush or truncate.",
        "group": "cf",
        "label": "TBL: Pending Reads/Writes",
        "mbean": "org.apache.cassandra.metrics:type=ColumnFamily,keyspace={keyspace},scope={table},name=PendingTasks",
        "metric_type": "gauge",
        "path": ["Value"],
        "scope": "cf",
        "storage_name": "getPendingTasks",
        "type": "jmx"
    },
    "cf-bf-space-used": {
        "aggregation_type": "average",
        "alerts_label": "Bloom Filter Space Used",
        "api_key": "cf-bf-space-used",
        "is_table_metric": true,
        "description": "The total size of all the SSTables' bloom filters for this table.",
        "from_unit": "gbToBytes",
        "group": "cf",
        "label": "TBL: Bloom Filter Space Used",
        "mbean": "org.apache.cassandra.metrics:type=ColumnFamily,keyspace={keyspace},scope={table},name=BloomFilterDiskSpaceUsed",
        "metric_type": "gauge",
        "path": ["Value"],
        "scope": "cf",
        "storage_name": "getBloomFilterSpaceUsed",
        "to_unit": "bytesToGb",
        "type": "jmx",
        "render_type": "filesize"
    },
    "cf-bf-false-positives": {
        "aggregation_type": "average",
        "alerts_label": "Bloom Filter False Positives",
        "api_key": "cf-bf-false-positives",
        "is_table_metric": true,
        "description": "Number of bloom filter false positives per second.",
        "group": "cf",
        "label": "TBL: Bloom Filter False Positives",
        "mbean": "org.apache.cassandra.metrics:type=ColumnFamily,keyspace={keyspace},scope={table},name=BloomFilterFalsePositives",
        "metric_type": "derive",
        "path": ["Value"],
        "scope": "cf",
        "storage_name": "getBloomFilterFalsePositives",
        "type": "jmx",
        "unit": "/sec"
    },
    "cf-bf-false-ratio": {
        "aggregation_type": "average",
        "alerts_label": "Bloom Filter False Positive Ratio",
        "api_key": "cf-bf-false-ratio",
        "is_table_metric": true,
        "description": "Percentage of bloom filter lookups that resulted in a false positive.",
        "group": "cf",
        "hardmax": 1,
        "label": "TBL: Bloom Filter False Positive Ratio",
        "mbean": "org.apache.cassandra.metrics:type=ColumnFamily,keyspace={keyspace},scope={table},name=RecentBloomFilterFalseRatio",
        "metric_type": "gauge",
        "minstep": 0.0005,
        "path": ["Value"],
        "precision": 4,
        "scope": "cf",
        "storage_name": "getRecentBloomFilterFalseRatio",
        "type": "jmx"
    },
    "cf-all-memtables-datasize": {
        "aggregation_type": "counter",
        "alerts_label": "Total Memtable Size",
        "api_key": "cf-all-memtables-datasize",
        "is_table_metric": true,
        "description": "An estimate of the space used in memory (including JVM overhead) for all memtables. This includes ones that are currently being flushed and related secondary indexes.",
        "from_unit": "gbToBytes",
        "group": "cf",
        "label": "TBL: Total Memtable Size",
        "mbean": "org.apache.cassandra.metrics:type=ColumnFamily,keyspace={keyspace},scope={table},name=AllMemtablesDataSize",
        "metric_type": "gauge",
        "min-version": "2.0.4",
        "path": ["Value"],
        "scope": "cf",
        "to_unit": "bytesToGb",
        "type": "jmx",
        "render_type": "filesize"
    },
    "solr-requests": {
        "aggregation_type": "counter",
        "alerts_label": "Search Requests",
        "api_key": "solr-requests",
        "is_table_metric": true,
        "description": "Requests per second made to a specific Solr core/index.",
        "group": "solr",
        "label": "Search: Requests",
        "mbean": "solr/{keyspace}.{table}:type=org.apache.solr.handler.component.SearchHandler,id=org.apache.solr.handler.component.SearchHandler",
        "other_mbeans": ["solr/{keyspace}.{table}:type=com.datastax.bdp.search.solr.handler.component.CqlSearchHandler,id=com.datastax.bdp.search.solr.handler.component.CqlSearchHandler"],
        "aggregate": "add",
        "metric_type": "derive",
        "path": ["requests"],
        "postprocess": ["ensure-int"],
        "scope": "solr",
        "storage_name": "getSolrRequests",
        "type": "jmx",
        "unit": "/sec"
    },
    "solr-avg-time-per-req": {
        "aggregation_type": "average",
        "alerts_label": "Search Request Latency",
        "api_key": "solr-avg-time-per-req",
        "is_table_metric": true,
        "description": "Average time a search query takes in a DSE cluster using DSE Search.",
        "group": "solr",
        "label": "Search: Request Latency",
        "mbean": "solr/{keyspace}.{table}:type=org.apache.solr.handler.component.SearchHandler,id=org.apache.solr.handler.component.SearchHandler",
        "other_mbeans": ["solr/{keyspace}.{table}:type=com.datastax.bdp.search.solr.handler.component.CqlSearchHandler,id=com.datastax.bdp.search.solr.handler.component.CqlSearchHandler"],
        "aggregate": "average",
        "metric_type": "gauge",
        "path": ["avgTimePerRequest"],
        "postprocess": ["ensure-float"],
        "scope": "solr",
        "storage_name": "getSolrAvgTimePerReq",
        "type": "jmx",
        "unit": "ms/request"
    },
    "solr-errors": {
        "aggregation_type": "counter",
        "alerts_label": "Search Errors",
        "api_key": "solr-errors",
        "is_table_metric": true,
        "description": "Errors per second that occur for a specific Solr core/index.",
        "group": "solr",
        "label": "Search: Errors",
        "mbean": "solr/{keyspace}.{table}:type=org.apache.solr.handler.component.SearchHandler,id=org.apache.solr.handler.component.SearchHandler",
        "other_mbeans": ["solr/{keyspace}.{table}:type=com.datastax.bdp.search.solr.handler.component.CqlSearchHandler,id=com.datastax.bdp.search.solr.handler.component.CqlSearchHandler"],
        "aggregate": "add",
        "metric_type": "derive",
        "path": ["errors"],
        "postprocess": ["ensure-int"],
        "scope": "solr",
        "storage_name": "getSolrErrors",
        "type": "jmx",
        "unit": "/sec"
    },
    "solr-timeouts": {
        "aggregation_type": "counter",
        "alerts_label": "Search Timeouts",
        "api_key": "solr-timeouts",
        "is_table_metric": true,
        "description": "Timeouts per second on a specific Solr core/index.",
        "group": "solr",
        "label": "Search: Timeouts",
        "mbean": "solr/{keyspace}.{table}:type=org.apache.solr.handler.component.SearchHandler,id=org.apache.solr.handler.component.SearchHandler",
        "other_mbeans": ["solr/{keyspace}.{table}:type=com.datastax.bdp.search.solr.handler.component.CqlSearchHandler,id=com.datastax.bdp.search.solr.handler.component.CqlSearchHandler"],
        "aggregate": "add",
        "metric_type": "derive",
        "path": ["timeouts"],
        "postprocess": ["ensure-int"],
        "scope": "solr",
        "storage_name": "getSolrTimeouts",
        "type": "jmx",
        "unit": "/sec"
    },
    "solr-index-size": {
        "aggregation_type": "counter",
        "allow_alerts": "true",
        "api_key": "solr-index-size",
        "is_table_metric": true,
        "description": "Size of the Solr core on disk.",
        "group": "solr",
        "label": "Search: Core Size",
        "mbean": "solr/{keyspace}.{table}:type=core,id={keyspace}.{table}",
        "metric_type": "gauge",
        "path": ["indexSizeInBytes"],
        "postprocess": ["solr-index-size"],
        "scope": "solr",
        "type": "jmx",
        "unit": "KB"
    },
    "os-memory": {
        "api_key": "os-memory",
        "description": "Stacked graph of used, cached, and free memory.",
        "group": "os",
        "label": "OS: Memory (stacked)",
        "metrics": [
            "os-memory-cached",
            "os-memory-used",
            "os-memory-buffers",
            "os-memory-shared",
            "os-memory-free"
        ],
        "os": "linux",
        "plot": "StackedAreas",
        "unit": "MB"
    },
    "os-memory-osx": {
        "api_key": "os-memory-osx",
        "description": "Stacked graph of used and free memory.",
        "group": "os",
        "label": "OS: Memory (stacked)",
        "metrics": [
            "os-memory-used",
            "os-memory-free"
        ],
        "os": "osx",
        "plot": "StackedAreas",
        "unit": "MB"
    },
    "os-memory-free": {
        "aggregation_type": "average",
        "alerts_label": "Memory Free",
        "allow_alerts": true,
        "api_key": "os-memory-free",
        "description": "Total system memory currently free.",
        "group": "os",
        "label": "OS: Memory Free",
        "metric_type": "gauge",
        "os": [
            "linux",
            "osx"
        ],
        "path": "free",
        "scope": "memory",
        "storage_name": "getMemFreeMb",
        "subtype": [
            "linux",
            "osx"
        ],
        "type": "system",
        "unit": "MB"
    },
    "os-memory-used": {
        "aggregation_type": "average",
        "alerts_label": "Memory Used",
        "allow_alerts": true,
        "api_key": "os-memory-used",
        "description": "Total system memory currently used.",
        "group": "os",
        "label": "OS: Memory Used",
        "metric_type": "gauge",
        "os": [
            "linux",
            "osx"
        ],
        "path": "used",
        "scope": "memory",
        "storage_name": "getMemUsedMb",
        "subtype": [
            "linux",
            "osx"
        ],
        "type": "system",
        "unit": "MB"
    },
    "os-memory-shared": {
        "aggregation_type": "average",
        "alerts_label": "Memory Shared",
        "allow_alerts": true,
        "api_key": "os-memory-shared",
        "description": "Total amount of memory in shared memory space.",
        "group": "os",
        "label": "OS: Memory Shared",
        "metric_type": "gauge",
        "os": "linux",
        "path": "shared",
        "scope": "memory",
        "storage_name": "getMemSharedMb",
        "subtype": ["linux"],
        "type": "system",
        "unit": "MB"
    },
    "os-memory-buffers": {
        "aggregation_type": "average",
        "alerts_label": "Memory Buffered",
        "allow_alerts": true,
        "api_key": "os-memory-buffers",
        "description": "Total system memory currently buffered.",
        "group": "os",
        "label": "OS: Memory Buffered",
        "metric_type": "gauge",
        "os": "linux",
        "path": "buffers",
        "scope": "memory",
        "storage_name": "getMemBuffersMb",
        "subtype": ["linux"],
        "type": "system",
        "unit": "MB"
    },
    "os-memory-cached": {
        "aggregation_type": "average",
        "alerts_label": "Memory Cached",
        "allow_alerts": true,
        "api_key": "os-memory-cached",
        "description": "Total system memory currently cached.",
        "group": "os",
        "label": "OS: Memory Cached",
        "metric_type": "gauge",
        "os": "linux",
        "path": "cached",
        "scope": "memory",
        "storage_name": "getMemCachedMb",
        "subtype": ["linux"],
        "type": "system",
        "unit": "MB"
    },
    "os-memory-win": {
        "api_key": "os-memory-win",
        "description": "Stacked graph of committed, cached, paged, non-paged, and free memory.",
        "group": "os",
        "label": "OS: Memory (stacked)",
        "metrics": [
            "os-memory-committed",
            "os-memory-sys-cache-resident",
            "os-memory-pool-paged",
            "os-memory-pool-nonpaged",
            "os-memory-avail"
        ],
        "os": "windows",
        "plot": "StackedAreas",
        "unit": "MB"
    },
    "os-memory-avail": {
        "aggregation_type": "average",
        "alerts_label": "Available Memory",
        "allow_alerts": true,
        "api_key": "os-memory-avail",
        "description": "Available physical memory.",
        "group": "os",
        "label": "OS: Memory Available",
        "metric_type": "gauge",
        "os": "windows",
        "path": null,
        "scope": "memory",
        "storage_name": "getMemAvailableMb",
        "subtype": ["win32"],
        "type": "system",
        "unit": "MB"
    },
    "os-memory-committed": {
        "aggregation_type": "average",
        "alerts_label": "Committed Memory",
        "allow_alerts": true,
        "api_key": "os-memory-committed",
        "description": "Memory in use by the operating system.",
        "group": "os",
        "label": "OS: Memory Committed",
        "metric_type": "gauge",
        "os": "windows",
        "path": null,
        "scope": "memory",
        "storage_name": "getMemCommittedMb",
        "subtype": ["win32"],
        "type": "system",
        "unit": "MB"
    },
    "os-memory-pool-paged": {
        "aggregation_type": "average",
        "alerts_label": "Pool Paged Resident Memory",
        "allow_alerts": true,
        "api_key": "os-memory-pool-paged",
        "description": "Allocated pool-paged-resident memory.",
        "group": "os",
        "label": "OS: Pool Paged Resident Memory",
        "metric_type": "gauge",
        "os": "windows",
        "path": null,
        "scope": "memory",
        "storage_name": "getMemPoolPagedResidentMb",
        "subtype": ["win32"],
        "type": "system",
        "unit": "MB"
    },
    "os-memory-pool-nonpaged": {
        "aggregation_type": "average",
        "alerts_label": "Pool Nonpaged Memory",
        "allow_alerts": true,
        "api_key": "os-memory-pool-nonpaged",
        "description": "Allocated pool-nonpaged memory.",
        "group": "os",
        "label": "OS: Pool Nonpaged Memory",
        "metric_type": "gauge",
        "os": "windows",
        "path": null,
        "scope": "memory",
        "storage_name": "getMemPoolNonpagedMb",
        "subtype": ["win32"],
        "type": "system",
        "unit": "MB"
    },
    "os-memory-sys-cache-resident": {
        "aggregation_type": "average",
        "alerts_label": "System Cache Resident Memory",
        "allow_alerts": true,
        "api_key": "os-memory-sys-cache-resident",
        "description": "Memory used by the file cache.",
        "group": "os",
        "label": "OS: System Cache Resident Memory",
        "metric_type": "gauge",
        "os": "windows",
        "path": null,
        "scope": "memory",
        "storage_name": "getMemSystemCacheResidentMb",
        "subtype": ["win32"],
        "type": "system",
        "unit": "MB"
    },
    "cpu": {
        "api_key": "cpu",
        "description": "Stacked graph of iowait, steal, nice, system, user, and idle CPU usage.",
        "group": "os",
        "label": "OS: CPU (stacked)",
        "metrics": [
            "os-cpu-steal",
            "os-cpu-iowait",
            "os-cpu-user",
            "os-cpu-nice",
            "os-cpu-idle",
            "os-cpu-system"
        ],
        "os": "linux",
        "plot": "StackedAreas",
        "render_type": "percentage"
    },
    "cpu-osx": {
        "api_key": "cpu-osx",
        "description": "Stacked graph of idle, user, and system CPU usage.",
        "group": "os",
        "label": "OS: CPU (stacked)",
        "metrics": [
            "os-cpu-idle",
            "os-cpu-user",
            "os-cpu-system"
        ],
        "os": "osx",
        "plot": "StackedAreas",
        "render_type": "percentage"
    },
    "cpu-win": {
        "api_key": "cpu-win",
        "description": "Stacked graph of user, privileged, and idle CPU usage.",
        "group": "os",
        "label": "OS: CPU (stacked)",
        "metrics": [
            "os-cpu-user",
            "os-cpu-privileged",
            "os-cpu-idle"
        ],
        "os": "windows",
        "plot": "StackedAreas",
        "render_type": "percentage"
    },
    "os-cpu-user": {
        "aggregation_type": "average",
        "alerts_label": "CPU: User",
        "api_key": "os-cpu-user",
        "description": "Time the CPU devotes to user processes.",
        "group": "os",
        "label": "OS: CPU User",
        "metric_type": "gauge",
        "path": null,
        "scope": "cpu",
        "storage_name": "getCpuUser",
        "subtype": ["win32"],
        "type": "system",
        "render_type": "percentage"
    },
    "os-cpu-system": {
        "aggregation_type": "average",
        "alerts_label": "CPU: System",
        "api_key": "os-cpu-system",
        "description": "Time the CPU devotes to system processes.",
        "group": "os",
        "label": "OS: CPU System",
        "metric_type": "gauge",
        "os": [
            "linux",
            "osx"
        ],
        "path": "%system",
        "scope": "cpu",
        "storage_name": "getCpuSystem",
        "subtype": [
            "linux",
            "osx"
        ],
        "type": "system",
        "render_type": "percentage"
    },
    "os-cpu-idle": {
        "aggregation_type": "average",
        "allow_alerts": false,
        "api_key": "os-cpu-idle",
        "description": "Time the CPU is idle.",
        "group": "os",
        "label": "OS: CPU Idle",
        "metric_type": "gauge",
        "path": "%idle",
        "scope": "cpu",
        "storage_name": "getCpuIdle",
        "subtype": [
            "linux",
            "osx"
        ],
        "type": "system",
        "render_type": "percentage"
    },
    "os-cpu-iowait": {
        "aggregation_type": "average",
        "alerts_label": "CPU: Iowait",
        "api_key": "os-cpu-iowait",
        "description": "Time the CPU devotes to waiting for I/O to complete.",
        "group": "os",
        "label": "OS: CPU Iowait",
        "metric_type": "gauge",
        "os": "linux",
        "path": "%iowait",
        "scope": "cpu",
        "storage_name": "getCpuIowait",
        "subtype": ["linux"],
        "type": "system",
        "render_type": "percentage"
    },
    "os-cpu-steal": {
        "aggregation_type": "average",
        "alerts_label": "CPU: Steal",
        "api_key": "os-cpu-steal",
        "description": "Time the CPU devotes to tasks stolen by virtual operating systems.",
        "group": "os",
        "label": "OS: CPU Steal",
        "metric_type": "gauge",
        "os": "linux",
        "path": "%steal",
        "scope": "cpu",
        "storage_name": "getCpuSteal",
        "subtype": ["linux"],
        "type": "system",
        "render_type": "percentage"
    },
    "os-cpu-nice": {
        "aggregation_type": "average",
        "alerts_label": "CPU: Nice",
        "api_key": "os-cpu-nice",
        "description": "Time the CPU devotes to processing nice tasks.",
        "group": "os",
        "label": "OS: CPU Nice",
        "metric_type": "gauge",
        "os": "linux",
        "path": "%nice",
        "scope": "cpu",
        "storage_name": "getCpuNice",
        "subtype": ["linux"],
        "type": "system",
        "render_type": "percentage"
    },
    "os-cpu-privileged": {
        "aggregation_type": "average",
        "alerts_label": "CPU: Privileged",
        "api_key": "os-cpu-privileged",
        "description": "Time the CPU devotes to processing privileged instructions.",
        "group": "os",
        "label": "OS: CPU Privileged",
        "metric_type": "gauge",
        "os": "windows",
        "path": null,
        "scope": "cpu",
        "storage_name": "getCpuPrivileged",
        "subtype": ["win32"],
        "type": "system",
        "render_type": "percentage"
    },
    "os-load": {
        "aggregation_type": "average",
        "alerts_label": "Load",
        "api_key": "os-load",
        "description": "Operating system load average. One minute value parsed from /proc/loadavg on Linux systems.",
        "group": "os",
        "label": "OS: Load",
        "metric_type": "gauge",
        "minstep": 0.05,
        "path": "la",
        "precision": 2,
        "scope": "la",
        "storage_name": "getSystemLoad",
        "subtype": [
            "linux",
            "osx",
            "win32"
        ],
        "type": "system",
        "type": "system"
    },
    "os-disk-usage": {
        "aggregation_type": "os_disk_usage",
        "alerts_label": "Disk Usage (%)",
        "api_key": "os-disk-usage",
        "description": "Disk space used by Cassandra at a given time.",
        "group": "os",
        "has_items": true,
        "label": "OS: Disk Usage (%)",
        "metric_type": "gauge",
        "partition_specific": true,
        "path": "percentage",
        "scope": "disk",
        "storage_name": "getDiskUsagePercent",
        "subtype": [
            "linux",
            "osx",
            "win32"
        ],
        "total": "<b>Total</b> - The sum of all the nodes disk used values divided by the sum of all the nodes total disk space.",
        "type": "system",
        "render_type": "percentage"
    },
    "os-disk-free": {
        "aggregation_type": "counter",
        "alerts_label": "Free Disk Space (GB)",
        "api_key": "os-disk-free",
        "description": "Free space on a specific disk partition.",
        "group": "os",
        "has_items": true,
        "label": "OS: Disk Free",
        "metric_type": "gauge",
        "partition_specific": true,
        "path": "free",
        "precision": 2,
        "scope": "disk",
        "storage_name": "getDiskSpaceGbFree",
        "subtype": [
            "linux",
            "osx",
            "win32"
        ],
        "type": "system",
        "unit": "GB"
    },
    "os-disk-used": {
        "aggregation_type": "counter",
        "alerts_label": "Used Disk Space (GB)",
        "api_key": "os-disk-used",
        "description": "Disk space used by Cassandra at a given time.",
        "group": "os",
        "has_items": true,
        "label": "OS: Disk Used",
        "metric_type": "gauge",
        "partition_specific": true,
        "path": "used",
        "precision": 2,
        "scope": "disk",
        "storage_name": "getDiskSpaceGbUsed",
        "subtype": [
            "linux",
            "osx",
            "win32"
        ],
        "type": "system",
        "unit": "GB"
    },
    "os-disk-read-throughput": {
        "aggregation_type": "average",
        "alerts_label": "Disk Read Throughput",
        "api_key": "os-disk-read-throughput",
        "description": "Average disk throughput for read operations.",
        "disk_specific": true,
        "group": "os",
        "has_items": true,
        "label": "OS: Disk Read Throughput",
        "metric_type": "gauge",
        "os": [
            "linux",
            "windows"
        ],
        "path": "Disk Read Bytes/sec",
        "postprocess": ["gb->mb"],
        "scope": "iostat",
        "storage_name": "getDiskMbsecRead",
        "subtype": ["win32"],
        "type": "system",
        "unit": "MB/sec"
    },
    "os-disk-write-throughput": {
        "aggregation_type": "average",
        "alerts_label": "Disk Write Throughput",
        "api_key": "os-disk-write-throughput",
        "description": "Average disk throughput for write operations.",
        "disk_specific": true,
        "group": "os",
        "has_items": true,
        "label": "OS: Disk Write Throughput",
        "metric_type": "gauge",
        "os": [
            "linux",
            "windows"
        ],
        "path": "Disk Write Bytes/sec",
        "postprocess": ["gb->mb"],
        "scope": "iostat",
        "storage_name": "getDiskMbsecWritten",
        "subtype": ["win32"],
        "type": "system",
        "unit": "MB/sec"
    },
    "os-disk-throughput": {
        "aggregation_type": "average",
        "alerts_label": "Disk Throughput",
        "api_key": "os-disk-throughput",
        "description": "Average disk throughput for read and write operations.",
        "disk_specific": true,
        "group": "os",
        "has_items": true,
        "label": "OS: Disk Throughput",
        "metric_type": "gauge",
        "minstep": 0.1,
        "os": "osx",
        "path": "MB/s",
        "scope": "iostat",
        "storage_name": "getDiskMbsec",
        "subtype": ["osx"],
        "type": "system",
        "unit": "MB/sec"
    },
    "os-disk-read-rate": {
        "aggregation_type": "average",
        "alerts_label": "Disk Read Rate",
        "api_key": "os-disk-read-rate",
        "description": "Rate of reads per second to the disk.",
        "disk_specific": true,
        "group": "os",
        "has_items": true,
        "label": "OS: Disk Read Rate",
        "metric_type": "gauge",
        "os": [
            "linux",
            "windows"
        ],
        "path": "Disk Reads/sec",
        "scope": "iostat",
        "storage_name": "getDiskReadsSec",
        "subtype": ["win32"],
        "type": "system",
        "unit": "/sec"
    },
    "os-disk-write-rate": {
        "aggregation_type": "average",
        "alerts_label": "Disk Write Rate",
        "api_key": "os-disk-write-rate",
        "description": "Rate of writes per second to the disk.",
        "disk_specific": true,
        "group": "os",
        "has_items": true,
        "label": "OS: Disk Writes Rate",
        "metric_type": "gauge",
        "os": [
            "linux",
            "windows"
        ],
        "path": "Disk Writes/sec",
        "scope": "iostat",
        "storage_name": "getDiskWritesSec",
        "subtype": ["win32"],
        "type": "system",
        "unit": "/sec"
    },
    "os-disk-await": {
        "aggregation_type": "average",
        "alerts_label": "Disk Latency",
        "api_key": "os-disk-await",
        "description": "Average completion time of each request to the disk.",
        "disk_specific": true,
        "group": "os",
        "has_items": true,
        "label": "OS: Disk Latency",
        "metric_type": "gauge",
        "os": [
            "linux",
            "windows"
        ],
        "path": "Avg. Disk sec/Transfer",
        "postprocess": ["us->ms"],
        "scope": "iostat",
        "storage_name": "getDiskAwaitMillis",
        "subtype": ["win32"],
        "type": "system",
        "unit": "ms"
    },
    "os-disk-request-size": {
        "aggregation_type": "average",
        "alerts_label": "Disk Request Size",
        "api_key": "os-disk-request-size",
        "description": "Average size of read requests issued to the disk.",
        "disk_specific": true,
        "group": "os",
        "has_items": true,
        "label": "OS: Disk Request Size",
        "metric_type": "gauge",
        "os": [
            "linux",
            "osx"
        ],
        "path": "avgrq-sz",
        "scope": "iostat",
        "storage_name": "getDiskAvgRequestSize",
        "subtype": ["linux"],
        "type": "system",
        "unit": "sectors"
    },
    "os-disk-request-size-kb": {
        "aggregation_type": "average",
        "alerts_label": "Disk Request Size",
        "api_key": "os-disk-request-size-kb",
        "description": "Average size of read requests issued to the disk.",
        "disk_specific": true,
        "group": "os",
        "has_items": true,
        "label": "OS: Disk Request Size",
        "metric_type": "gauge",
        "os": "windows",
        "path": "Avg. Disk Bytes/Transfer",
        "postprocess": ["mb->kb"],
        "scope": "iostat",
        "storage_name": "getDiskAvgRequestKb",
        "subtype": ["win32"],
        "type": "system",
        "unit": "KB"
    },
    "os-disk-queue-size": {
        "aggregation_type": "average",
        "alerts_label": "Disk Queue Size",
        "api_key": "os-disk-queue-size",
        "description": "Average number of requests queued due to disk latency issues.",
        "disk_specific": true,
        "group": "os",
        "has_items": true,
        "label": "OS: Disk Queue Size",
        "metric_type": "gauge",
        "os": [
            "linux",
            "windows"
        ],
        "path": "Avg. Disk Queue Length",
        "scope": "iostat",
        "storage_name": "getDiskAvgQueueSize",
        "subtype": ["win32"],
        "type": "system",
        "unit": "requests"
    },
    "os-disk-utilization": {
        "aggregation_type": "average",
        "alerts_label": "Disk Utilization",
        "api_key": "os-disk-utilization",
        "description": "CPU time consumed by disk I/O.",
        "disk_specific": true,
        "group": "os",
        "has_items": true,
        "label": "OS: Disk Utilization",
        "metric_type": "gauge",
        "os": [
            "linux",
            "windows"
        ],
        "path": "% Disk Time",
        "scope": "iostat",
        "storage_name": "getDiskUtilPercent",
        "subtype": ["win32"],
        "type": "system",
        "render_type": "percentage"
    },
    "os-net-received": {
        "aggregation_type": "counter",
        "allow_alerts": false,
        "api_key": "os-net-received",
        "description": "Speed of data received from the network.",
        "group": "os",
        "has_items": true,
        "label": "OS: Net Received",
        "metric_type": "gauge",
        "path": "received",
        "scope": "network",
        "storage_name": "getNetKbReceived",
        "subtype": [
            "linux",
            "osx"
        ],
        "to_unit": "perMin",
        "type": "system",
        "unit": "KB/sec"
    },
    "os-net-sent": {
        "aggregation_type": "counter",
        "allow_alerts": false,
        "api_key": "os-net-sent",
        "description": "Speed of data sent across the network.",
        "group": "os",
        "has_items": true,
        "label": "OS: Net Sent",
        "metric_type": "gauge",
        "path": "sent",
        "scope": "network",
        "storage_name": "getNetKbSent",
        "subtype": [
            "linux",
            "osx"
        ],
        "to_unit": "perMin",
        "type": "system",
        "unit": "KB/sec"
    },
    "dashboard-read-write": {
        "label": "Cluster Reads & Writes",
        "metrics": [
            {
                "key": "write-ops",
                "label": "Writes"
            },
            {
                "key": "read-ops",
                "label": "Reads"
            }
        ],
        "selectable": false,
        "unit": "/sec"
    },
    "dashboard-latency": {
        "label": "Cluster Latency",
        "metrics": [
            {
                "key": "write-histogram",
                "label": "Writes"
            },
            {
                "key": "read-histogram",
                "label": "Reads"
            }
        ],
        "minstep": 0.1,
        "selectable": false,
        "unit": "ms/op"
    },
    "cassandramemory": {
        "group": "cassandra",
        "label": "Cassandra JVM Memory Usage",
        "metrics": [
            "heap-used",
            "heap-max"
        ],
        "selectable": false,
        "render_type": "filesize"
    },
    "cf-sstable-size": {
        "is_table_metric": true,
        "group": "cf",
        "label": "TBL: SSTable Size",
        "metrics": [
            "cf-live-disk-used",
            "cf-total-disk-used"
        ],
        "selectable": false,
        "render_type": "filesize"
    },
    "os-disk-space": {
        "group": "os",
        "has_items": true,
        "label": "OS: Disk Usage (GB)",
        "metrics": [
            "os-disk-free",
            "os-disk-used"
        ],
        "precision": 2,
        "selectable": false,
        "unit": "GB"
    },
    "os-disk-throughput-grouped": {
        "group": "os",
        "has_items": true,
        "label": "OS: Disk Throughput",
        "metrics": [
            "os-disk-write-throughput",
            "os-disk-read-throughput"
        ],
        "minstep": 0.1,
        "os": [
            "linux",
            "windows"
        ],
        "selectable": false,
        "unit": "MB/sec"
    },
    "os-disk-rate": {
        "alerts_label": "Disk Rates",
        "group": "os",
        "has_items": true,
        "label": "OS: Disk Rates",
        "metrics": [
            "os-disk-write-rate",
            "os-disk-read-rate"
        ],
        "os": [
            "linux",
            "windows"
        ],
        "selectable": false,
        "unit": "/sec"
    },
    "os-net-traffic": {
        "group": "os",
        "has_items": true,
        "label": "OS: Network Traffic",
        "metrics": [
            "os-net-received",
            "os-net-sent"
        ],
        "selectable": false,
        "to_unit": "perMin",
        "unit": "KB/sec"
    },
    "os-net-sent-win": {
        "aggregation_type": "counter",
        "api_key": "os-net-sent-win",
        "description": "Speed of data sent across the network.",
        "group": "os",
        "label": "OS: Net Sent",
        "metric_type": "gauge",
        "path": null,
        "scope": "network",
        "storage_name": "getNetKbSecSent",
        "subtype": ["win32"],
        "selectable": false,
        "type": "system"
    },
    "os-net-received-win": {
        "aggregation_type": "counter",
        "api_key": "os-net-received-win",
        "description": "Speed of data received from the network.",
        "group": "os",
        "label": "OS: Net Received",
        "metric_type": "gauge",
        "path": null,
        "scope": "network",
        "storage_name": "getNetKbSecReceived",
        "subtype": ["win32"],
        "selectable": false,
        "type": "system"
    },
    "speculative-retries": {
        "aggregation_type": "counter",
        "allow_alerts": true,
        "api_key": "speculative-retries",
        "is_table_metric": false,
        "description": "Number of speculative retries for all column families.",
        "group": "cassandra",
        "label": "Speculative Retries",
        "mbean": "org.apache.cassandra.metrics:type=Table,name=SpeculativeRetries",
        "metric_type": "gauge",
        "path": ["Value"],
        "scope": "general",
        "type": "jmx",
        "unit": "retries"
    },
    "cf-speculative-retries": {
        "aggregation_type": "counter",
        "allow_alerts": true,
        "api_key": "cf-speculative-retries",
        "is_table_metric": true,
        "description": "Number of speculative retries for this table.",
        "group": "cf",
        "label": "TBL: Speculative Retries",
        "mbean": "org.apache.cassandra.metrics:type=Table,keyspace={keyspace},scope={table},name=SpeculativeRetries",
        "metric_type": "gauge",
        "path": ["Count"],
        "scope": "cf",
        "type": "jmx",
        "unit": "retries"
    },
    "stream-out-total": {
        "aggregation_type": "counter",
        "allow_alerts": true,
        "api_key": "stream-out-total",
        "description": "Data streamed out from this node to all other nodes, for all tables.",
        "group": "cassandra",
        "label": "Stream Data Out - Total",
        "mbean": "org.apache.cassandra.metrics:type=Streaming,name=TotalOutgoingBytes",
        "metric_type": "derive",
        "path": ["Count"],
        "scope": "general",
        "type": "jmx",
        "from_unit": "gbToBytes",
        "to_unit": "bytesToGb",
        "unit": "/sec",
        "render_type": "filesize"
    },
    "stream-in-total": {
        "aggregation_type": "counter",
        "allow_alerts": true,
        "api_key": "stream-in-total",
        "description": "Data streams in to this node from all other nodes, for all tables.",
        "group": "cassandra",
        "label": "Stream Data In - Total",
        "mbean": "org.apache.cassandra.metrics:type=Streaming,name=TotalIncomingBytes",
        "metric_type": "derive",
        "path": ["Count"],
        "scope": "general",
        "type": "jmx",
        "from_unit": "gbToBytes",
        "to_unit": "bytesToGb",
        "unit": "/sec",
        "render_type": "filesize"
    },
    "hint-creation-rate": {
        "aggregation_type": "counter",
        "allow_alerts": true,
        "api_key": "hint-creation-rate",
        "description": "Rate at which new individual hints are stored on this node, to be replayed to peers.",
        "group": "cassandra",
        "label": "Hint Creation Rate",
        "mbean": "org.apache.cassandra.metrics:type=Storage,name=TotalHints",
        "metric_type": "derive",
        "path": ["Count"],
        "priority": 40,
        "scope": "general",
        "type": "jmx",
        "unit": "/sec"
    }
}
